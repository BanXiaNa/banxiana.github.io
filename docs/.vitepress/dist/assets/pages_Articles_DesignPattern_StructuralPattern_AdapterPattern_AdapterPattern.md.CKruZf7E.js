import{_ as e,c as t,o as r,aj as n}from"./chunks/framework.iQ8U7nGd.js";const c=JSON.parse('{"title":"适配器模式","description":"","frontmatter":{},"headers":[],"relativePath":"pages/Articles/DesignPattern/StructuralPattern/AdapterPattern/AdapterPattern.md","filePath":"pages/Articles/DesignPattern/StructuralPattern/AdapterPattern/AdapterPattern.md","lastUpdated":1770565939000}'),p={name:"pages/Articles/DesignPattern/StructuralPattern/AdapterPattern/AdapterPattern.md"};function s(i,a,l,o,h,d){return r(),t("div",null,[...a[0]||(a[0]=[n('<h1 id="适配器模式" tabindex="-1">适配器模式 <a class="header-anchor" href="#适配器模式" aria-label="Permalink to “适配器模式”">​</a></h1><p><a href="https://github.com/BanXiaNa/DesignPattern/tree/master/DesignPattern/StructuralPattern/AdapterPattern" target="_blank" rel="noreferrer"><img src="https://img.shields.io/badge/GitHub-%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0-181717?style=flat-square&amp;logo=github" alt="GitHub"></a><a href="https://github.com/BanXiaNa/DesignPattern/tree/master/DesignPattern/StructuralPattern/AdapterPattern" target="_blank" rel="noreferrer"><img src="https://img.shields.io/badge/Java-%E5%AE%9E%E7%8E%B0%E8%AF%AD%E8%A8%80-ED8B00?style=flat-square&amp;logo=java" alt="Java"></a></p><h2 id="📖-概述" tabindex="-1">📖 概述 <a class="header-anchor" href="#📖-概述" aria-label="Permalink to “📖 概述”">​</a></h2><p><strong>概述：</strong></p><p>有时候我们希望使用的接口并不是已经提供好的接口，但是功能类似，就像内存卡不能直接插到只有USB的电脑一样，适配器模式就是充当这个读卡器的存在</p><p>首先要明确的是，我们要对两个接口做适配，这里拿USB的 TypeC To TypeA 来举例子，就像扩展坞一样</p><p>我们创建接口：TypeA、TypeC和他们的实现类，来模拟两个不同的接口</p><h2 id="🔗-相关资源" tabindex="-1">🔗 相关资源 <a class="header-anchor" href="#🔗-相关资源" aria-label="Permalink to “🔗 相关资源”">​</a></h2><ul><li><strong>📂 <a href="https://github.com/BanXiaNa/DesignPattern/tree/master/DesignPattern/StructuralPattern/AdapterPattern" target="_blank" rel="noreferrer">完整源码</a></strong> - 查看适配器模式的完整 Java 实现</li><li><strong>📋 <a href="https://github.com/BanXiaNa/DesignPattern" target="_blank" rel="noreferrer">项目主页</a></strong> - 返回设计模式项目主页</li></ul><hr><h2 id="🏗️-类适配器" tabindex="-1">🏗️ 类适配器 <a class="header-anchor" href="#🏗️-类适配器" aria-label="Permalink to “🏗️ 类适配器”">​</a></h2><p>通过创建一个继承TypeC的功能并且实现TypeA的类来达到适配的目的</p><p><strong>栗子：</strong></p><p>创建 ClassAdapter 对象，让他继承 TypeC 的实现类，然后去实现 TypeA 的接口，然后在实现的方法里调用继承自 TypeC 的方法就可以了</p><h2 id="🔧-对象适配器" tabindex="-1">🔧 对象适配器 <a class="header-anchor" href="#🔧-对象适配器" aria-label="Permalink to “🔧 对象适配器”">​</a></h2><p>OK，如果你嫌弃类适配器要做继承还要做实现太麻烦的话，反正目的是调用TypeC的方法，我直接在适配器里面声明一个TypeC 的对象不就行了</p><p><strong>栗子：</strong></p><p>创建 ObjectAdapter 类，实现 TypeA 方法，在类内部，声明一个TypeC的实现类，然后调用方法</p><p>当然我们可以更加灵活一点，在适配器的构造方法传入 TypeC的对象更棒</p><h2 id="⚙️-接口适配器" tabindex="-1">⚙️ 接口适配器 <a class="header-anchor" href="#⚙️-接口适配器" aria-label="Permalink to “⚙️ 接口适配器”">​</a></h2><p>有时候我们并不需要对TypeC的所有方法都实现，这些不需要实现的方法也不会被用到。但是前面二者显然不能做到这一点，我们可以创建一个抽象类，对TypeA的所有方法提供一个空方法，然后这个抽象类的子类就可以选择性的实现这些方法</p><p><strong>栗子：</strong></p>',22)])])}const P=e(p,[["render",s]]);export{c as __pageData,P as default};
