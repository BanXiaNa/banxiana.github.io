import{_ as i,c as s,o as t,aj as e}from"./chunks/framework.iQ8U7nGd.js";const c=JSON.parse('{"title":"事务","description":"","frontmatter":{},"headers":[],"relativePath":"pages/Documents/SQL/05：事务.md","filePath":"pages/Documents/SQL/05：事务.md","lastUpdated":1770833529000}'),h={name:"pages/Documents/SQL/05：事务.md"};function l(d,a,r,n,p,k){return t(),s("div",null,[...a[0]||(a[0]=[e('<h1 id="事务" tabindex="-1">事务 <a class="header-anchor" href="#事务" aria-label="Permalink to “事务”">​</a></h1><p>定义：事务是一堆操作的集合，在操作时，一般一齐提交给系统进行处理，所以这些操作一般会一起成功或者一起失败 如果中途失败的话，就要进行事务的回滚，一般事务会默认自动提交</p><h2 id="事务操作" tabindex="-1">事务操作 <a class="header-anchor" href="#事务操作" aria-label="Permalink to “事务操作”">​</a></h2><h3 id="查看事务提交方式" tabindex="-1">查看事务提交方式 <a class="header-anchor" href="#查看事务提交方式" aria-label="Permalink to “查看事务提交方式”">​</a></h3><div class="language-sql"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">select</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @@autocommit;</span></span></code></pre></div><p>默认提交方式是1：自动提交 0：手动提交</p><h3 id="提交事务" tabindex="-1">提交事务 <a class="header-anchor" href="#提交事务" aria-label="Permalink to “提交事务”">​</a></h3><p>commit;</p><h3 id="回滚事务" tabindex="-1">回滚事务 <a class="header-anchor" href="#回滚事务" aria-label="Permalink to “回滚事务”">​</a></h3><p>rollback;</p><hr><h2 id="四大特性-acid" tabindex="-1">四大特性（ACID） <a class="header-anchor" href="#四大特性-acid" aria-label="Permalink to “四大特性（ACID）”">​</a></h2><p>​ 原子性：事务是不可分割的最小操作单元，要么全部成功，要么全部失败 ​ 如果执行结果不一致，就会导致数据不一致，数据库的数据就会出错 ​ 一致性：事务完成时，必须使所有数据保持一致状态 ​ 隔离性：数据库系统提供隔离特性，保证事务不受外部并发操作影响的独立环境执行 ​ 持久性：事务一旦提交或者回滚，对数据库的数据的改变就是永久的</p><hr><h2 id="并发事务问题" tabindex="-1">并发事务问题： <a class="header-anchor" href="#并发事务问题" aria-label="Permalink to “并发事务问题：”">​</a></h2><p>​ 数据库涉及数据的修改还有操作的并发，就会产生一些常见问题，常见的：脏读，不可重复读，幻读 ​ 脏读：一个事务读取到另外一个事务没有提交的数据 ​ 不可重复读：一个事务先后读取同一条记录，但读取到的数据不相同 ​ 幻读：一个事务在读取一行数据时，数据不存在，但是插入时，数据又存在了</p><hr><h2 id="事务的隔离级别" tabindex="-1">事务的隔离级别： <a class="header-anchor" href="#事务的隔离级别" aria-label="Permalink to “事务的隔离级别：”">​</a></h2><p>为了防止并发产生的问题，MYSQL设计了一系列的隔离等级 越安全的隔离方式，性能越低</p><table tabindex="0"><thead><tr><th>事务隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>read uncommitted</td><td>1</td><td>1</td><td>1</td></tr><tr><td>reda committed</td><td>0</td><td>1</td><td>1</td></tr><tr><td>repeatable read(默认)</td><td>0</td><td>0</td><td>0</td></tr><tr><td>serializable</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><p>0代表不会发生</p><p><strong>Repeatable Read</strong>：可重复读</p><p>​ 确保了在同一事务中多次读取相同记录的结果是一致的。 ​ 可以通过在读取记录时对其加锁来实现的，一旦某个事务读取了某条记录，那么在该事务完成之前，其他事务是无法修改该记录的。 ​ Mysql使用了MVCC来实现这个操作，数据在被读取时会被创建一个快照，当这个事务中的其他读取操作进行时，只能读取到当前快 照的数据，从而保证了可重复读的特性，又不会导致阻塞</p><h3 id="查看事务隔离级别" tabindex="-1">查看事务隔离级别 <a class="header-anchor" href="#查看事务隔离级别" aria-label="Permalink to “查看事务隔离级别”">​</a></h3><div class="language-sql"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">select</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> @@transaction_isolation;</span></span></code></pre></div><h3 id="修改事务的隔离级别" tabindex="-1">修改事务的隔离级别 <a class="header-anchor" href="#修改事务的隔离级别" aria-label="Permalink to “修改事务的隔离级别”">​</a></h3><div class="language-sql"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 范围 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">transaction</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> isolation</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> level</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">read</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> uncommitted</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> , reda </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">committed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> , </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">repeatable</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> read</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> , </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">serializable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} ;</span></span></code></pre></div><p>范围：session 设置当前会话窗口 global 对全部的会话窗口有效</p><hr><h1 id="" tabindex="-1"><a class="header-anchor" href="#" aria-label="Permalink to “”">​</a></h1>',30)])])}const g=i(h,[["render",l]]);export{c as __pageData,g as default};
