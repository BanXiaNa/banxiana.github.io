import{_ as a,c as t,o as r,aj as n}from"./chunks/framework.iQ8U7nGd.js";const c=JSON.parse('{"title":"建造者模式","description":"","frontmatter":{},"headers":[],"relativePath":"pages/Articles/DesignPattern/CreationalPattern/BuilderPattern/BuilderPattern.md","filePath":"pages/Articles/DesignPattern/CreationalPattern/BuilderPattern/BuilderPattern.md","lastUpdated":1770565939000}'),i={name:"pages/Articles/DesignPattern/CreationalPattern/BuilderPattern/BuilderPattern.md"};function l(s,e,o,p,d,g){return r(),t("div",null,[...e[0]||(e[0]=[n('<h1 id="建造者模式" tabindex="-1">建造者模式 <a class="header-anchor" href="#建造者模式" aria-label="Permalink to “建造者模式”">​</a></h1><p><a href="https://github.com/BanXiaNa/DesignPattern/tree/master/DesignPattern/CreationalPattern/BuilderPattern" target="_blank" rel="noreferrer"><img src="https://img.shields.io/badge/GitHub-%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0-181717?style=flat-square&amp;logo=github" alt="GitHub"></a><a href="https://github.com/BanXiaNa/DesignPattern/tree/master/DesignPattern/CreationalPattern/BuilderPattern" target="_blank" rel="noreferrer"><img src="https://img.shields.io/badge/Java-%E5%AE%9E%E7%8E%B0%E8%AF%AD%E8%A8%80-ED8B00?style=flat-square&amp;logo=java" alt="Java"></a></p><h2 id="📖-概述" tabindex="-1">📖 概述 <a class="header-anchor" href="#📖-概述" aria-label="Permalink to “📖 概述”">​</a></h2><p>在开发过程中，我们会遇到比较复杂的对象需要被创建，这里特指需要很多对象组合到一起的复杂对象的创建。 我们发现，这些玩意在创建的过程中，仅仅是因为组合方式不同，就会显得很麻烦。</p><p>比如，要创建一个AIClient对象，他就需要一堆的子对象，比如API，模型，顾问，提示词等等等等，我们要做的就是创建这些小零件，然后把他们拼起来。 稍微解构一下就会发现，这任务分为两部分：创建基本部件。组合复杂对象。 我们发现，基本的组件是不会变的，我们可以创建一堆的API，用到那个就调哪个，但是创建出来的对象是变化的，我们没办法预测会用到什么对象，所以我们把这个拆分出来，分别实现。</p><h2 id="🔗-相关资源" tabindex="-1">🔗 相关资源 <a class="header-anchor" href="#🔗-相关资源" aria-label="Permalink to “🔗 相关资源”">​</a></h2><ul><li><strong>📂 <a href="https://github.com/BanXiaNa/DesignPattern/tree/master/DesignPattern/CreationalPattern/BuilderPattern" target="_blank" rel="noreferrer">完整源码</a></strong> - 查看建造者模式的完整 Java 实现</li><li><strong>📋 <a href="https://github.com/BanXiaNa/DesignPattern" target="_blank" rel="noreferrer">项目主页</a></strong> - 返回设计模式项目主页</li></ul><hr><h2 id="🏗️-模式角色" tabindex="-1">🏗️ 模式角色 <a class="header-anchor" href="#🏗️-模式角色" aria-label="Permalink to “🏗️ 模式角色”">​</a></h2><p>建造者模式一般有四个角色：</p><ul><li><p><strong>产品（Product）</strong>：最终要创建的复杂对象。</p></li><li><p><strong>抽象建造者（Builder）</strong>：定义创建产品各个部件的抽象接口，通常包含多个 <code>buildPart()</code> 方法和一个 <code>getResult()</code> 方法。</p></li><li><p><strong>具体建造者（ConcreteBuilder）</strong>：实现抽象接口，负责具体部件的构造逻辑，并保存创建好的对象。</p></li><li><p><strong>指挥者（Director）</strong>：负责安排构建的<strong>步骤顺序</strong>。它不直接操作产品，而是通过 Builder 接口来完成对象的创建。</p></li></ul><h2 id="💡-实现示例" tabindex="-1">💡 实现示例 <a class="header-anchor" href="#💡-实现示例" aria-label="Permalink to “💡 实现示例”">​</a></h2><p><strong>栗子：</strong></p><p>我们现在创建一个电脑对象：computer</p><p>他的抽象建造者：ComputerBuilder 实现类：HighEndComputerBuilder、LowEndComputerBuilder</p><p>指挥者：Director</p><p>最后，调用指挥者的方法，传入指定的建造者实现类，就可以进行建造了。</p><h2 id="⚠️-注意事项" tabindex="-1">⚠️ 注意事项 <a class="header-anchor" href="#⚠️-注意事项" aria-label="Permalink to “⚠️ 注意事项”">​</a></h2><p><strong>问题：</strong></p><p>模板这玩意看起来很笨重，好像并不能体现自由搭配的效果，如果我们把CPU换成一个具体的CPU类就好很多，全看理解这玩意 有点过度设计的嫌疑了</p><p>会多出来很多类</p><p>而且，维护很困难，如果有一天，Builder被修改了......</p><p><strong>结尾：</strong></p><p>其实@Builder有点类似这玩意，并且更好用</p>',24)])])}const u=a(i,[["render",l]]);export{c as __pageData,u as default};
