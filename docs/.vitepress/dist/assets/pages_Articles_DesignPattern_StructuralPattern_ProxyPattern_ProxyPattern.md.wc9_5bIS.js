import{_ as a,c as t,o as e,al as n}from"./chunks/framework.CbWvOqpl.js";const c=JSON.parse('{"title":"代理模式","description":"","frontmatter":{},"headers":[],"relativePath":"pages/Articles/DesignPattern/StructuralPattern/ProxyPattern/ProxyPattern.md","filePath":"pages/Articles/DesignPattern/StructuralPattern/ProxyPattern/ProxyPattern.md","lastUpdated":1770565939000}'),o={name:"pages/Articles/DesignPattern/StructuralPattern/ProxyPattern/ProxyPattern.md"};function s(i,r,l,p,g,h){return e(),t("div",null,[...r[0]||(r[0]=[n('<h1 id="代理模式" tabindex="-1">代理模式 <a class="header-anchor" href="#代理模式" aria-label="Permalink to “代理模式”">​</a></h1><p><a href="https://github.com/BanXiaNa/DesignPattern/tree/master/DesignPattern/StructuralPattern/ProxyPattern" target="_blank" rel="noreferrer"><img src="https://img.shields.io/badge/GitHub-%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0-181717?style=flat-square&amp;logo=github" alt="GitHub"></a><a href="https://github.com/BanXiaNa/DesignPattern/tree/master/DesignPattern/StructuralPattern/ProxyPattern" target="_blank" rel="noreferrer"><img src="https://img.shields.io/badge/Java-%E5%AE%9E%E7%8E%B0%E8%AF%AD%E8%A8%80-ED8B00?style=flat-square&amp;logo=java" alt="Java"></a></p><h2 id="📖-概述" tabindex="-1">📖 概述 <a class="header-anchor" href="#📖-概述" aria-label="Permalink to “📖 概述”">​</a></h2><p><strong>概述：</strong></p><blockquote><p>在代理模式（Proxy Pattern）中，一个类代表另一个类的功能，这种类型的设计模式属于结构型模式。</p><p>代理模式通过引入一个代理对象来控制对原对象的访问。代理对象在客户端和目标对象之间充当中介，负责将客户端的请求转发给目标对象，同时可以在转发请求前后进行额外的处理。</p><p>在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。</p></blockquote><p>比如，我们要给现在的类加一个权限控制，我们就可以使用代理模式</p><h2 id="🔗-相关资源" tabindex="-1">🔗 相关资源 <a class="header-anchor" href="#🔗-相关资源" aria-label="Permalink to “🔗 相关资源”">​</a></h2><ul><li><strong>📂 <a href="https://github.com/BanXiaNa/DesignPattern/tree/master/DesignPattern/StructuralPattern/ProxyPattern" target="_blank" rel="noreferrer">完整源码</a></strong> - 查看代理模式的完整 Java 实现</li><li><strong>📋 <a href="https://github.com/BanXiaNa/DesignPattern" target="_blank" rel="noreferrer">项目主页</a></strong> - 返回设计模式项目主页</li></ul><hr><h2 id="🏗️-静态代理" tabindex="-1">🏗️ 静态代理 <a class="header-anchor" href="#🏗️-静态代理" aria-label="Permalink to “🏗️ 静态代理”">​</a></h2><p><strong>概述：</strong></p><p>稍微细考一下就可以做到这一点，我们可以创建一个实现了我们要控制类的接口，然后，让代理类去引用被代理的对象，在实现接口的方法中调用源对象的方法，然后在方法执行前就加上权限控制就可以了，这个和装饰器模式有点类似，但是他们强调的逻辑不一样，后面会讲述</p><p><strong>栗子：</strong></p><p><strong>IUserService：</strong> 创建一个接口作为代理接口</p><p><strong>UserService：</strong> 继承代理接口，作为被代理的对象</p><p><strong>StaticProxy：</strong> 继承代理接口，引用被代理的对象作为构造的参数</p><p><strong>问题：</strong></p><p>这玩意的问题很明显，我们有多少个接口，就得创建多少个代理对象，这显然不是很健康，而且，接口更新之后，我们就得挨个的更新代理对象，这更不健康了，于是就有了动态代理</p><h2 id="⚡-动态代理" tabindex="-1">⚡ 动态代理 <a class="header-anchor" href="#⚡-动态代理" aria-label="Permalink to “⚡ 动态代理”">​</a></h2><p><strong>概述：</strong></p><p>是什么东西如此方便且优雅呢，当然是我们JDK的API啦</p><p>我们需要写一个继承 InvocationHandler 的类，然后实现它的方法，在里面编写我们要添加的功能，这个方法有三个参数： <strong>proxy：</strong> 代理对象 <strong>method：</strong> 当前执行的方法 <strong>args：</strong> 当前方法执行的参数</p><p>调用的时候使用 Proxy.newProxyInstance 方法，这个方法同样也有一堆的参数： <strong>loader：</strong> 代理对象的类加载器，一般要被代理对象的类加载器 <strong>interfaces：</strong> 代理对象要实现的接口，同上，也是用被代理对象的 <strong>h：</strong> 我们创建的执行类</p><p>然后就可以美美使用了</p><p><strong>栗子：</strong></p><p><strong>DynamicProxy：</strong> 作为代理对象的执行器，实现 InvocationHandler 接口</p><h2 id="✅-优点" tabindex="-1">✅ 优点 <a class="header-anchor" href="#✅-优点" aria-label="Permalink to “✅ 优点”">​</a></h2><p>优点就是静态的缺点</p><h2 id="⚠️-缺点" tabindex="-1">⚠️ 缺点 <a class="header-anchor" href="#⚠️-缺点" aria-label="Permalink to “⚠️ 缺点”">​</a></h2><p>我们很容易就发现，这玩意只能支持接口代理，这是来自设计的桎梏</p><h2 id="🔄-和装饰器模式的区别" tabindex="-1">🔄 和装饰器模式的区别 <a class="header-anchor" href="#🔄-和装饰器模式的区别" aria-label="Permalink to “🔄 和装饰器模式的区别”">​</a></h2><p>其实看起来很像，都是往类上添加功能，但是强调的本质还是不一样的，装饰器强调的主要是往类上加东西，扩展本来的功能，比如给订单加一个自动计费的功能，而代理模式更强调控制，比如入参检查，权限校验之类的</p>',32)])])}const d=a(o,[["render",s]]);export{c as __pageData,d as default};
