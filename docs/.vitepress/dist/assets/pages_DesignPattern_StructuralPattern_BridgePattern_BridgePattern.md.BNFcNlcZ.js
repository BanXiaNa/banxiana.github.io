import{_ as t,c as e,o as r,aj as n}from"./chunks/framework.iQ8U7nGd.js";const d=JSON.parse('{"title":"桥接模式","description":"","frontmatter":{},"headers":[],"relativePath":"pages/DesignPattern/StructuralPattern/BridgePattern/BridgePattern.md","filePath":"pages/DesignPattern/StructuralPattern/BridgePattern/BridgePattern.md"}'),i={name:"pages/DesignPattern/StructuralPattern/BridgePattern/BridgePattern.md"};function s(l,a,o,g,h,p){return r(),e("div",null,[...a[0]||(a[0]=[n('<h1 id="桥接模式" tabindex="-1">桥接模式 <a class="header-anchor" href="#桥接模式" aria-label="Permalink to “桥接模式”">​</a></h1><p><a href="https://github.com/BanXiaNa/DesignPattern/tree/master/DesignPattern/StructuralPattern/BridgePattern" target="_blank" rel="noreferrer"><img src="https://img.shields.io/badge/GitHub-%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0-181717?style=flat-square&amp;logo=github" alt="GitHub"></a><a href="https://github.com/BanXiaNa/DesignPattern/tree/master/DesignPattern/StructuralPattern/BridgePattern" target="_blank" rel="noreferrer"><img src="https://img.shields.io/badge/Java-%E5%AE%9E%E7%8E%B0%E8%AF%AD%E8%A8%80-ED8B00?style=flat-square&amp;logo=java" alt="Java"></a></p><h2 id="📖-概述" tabindex="-1">📖 概述 <a class="header-anchor" href="#📖-概述" aria-label="Permalink to “📖 概述”">​</a></h2><p><strong>概述：</strong></p><p>如果我们有一个类需要从两个维度去扩展功能，最直接的方法就是创建两个维度乘积的类的数目，但是基于组合优于继承的思想，我们肯定不能这么做，这么做不仅会大大增加类的数目，也会增加开发成本</p><p>比如现在有两个手机，OPPO和VIVO手机，两个手机都能启动腾讯云和阿里云，我们这个时候如果采用继承的方式，就会产生四个新类，而且，随着手机和软件的种类越多，这种子类会越来越多，肯定不是最好的解决方案</p><p>动动脑子就不难发现，我们可以将两个维度拆开，用一个维度去引用另外一个维度，这样就不用创建这么多的子类了，也不用花费很高的成本进行后期的维护，我们只需要在类变更的时候更改一下引用就可以了</p><h2 id="🔗-相关资源" tabindex="-1">🔗 相关资源 <a class="header-anchor" href="#🔗-相关资源" aria-label="Permalink to “🔗 相关资源”">​</a></h2><ul><li><strong>📂 <a href="https://github.com/BanXiaNa/DesignPattern/tree/master/DesignPattern/StructuralPattern/BridgePattern" target="_blank" rel="noreferrer">完整源码</a></strong> - 查看桥接模式的完整 Java 实现</li><li><strong>📋 <a href="https://github.com/BanXiaNa/DesignPattern" target="_blank" rel="noreferrer">项目主页</a></strong> - 返回设计模式项目主页</li></ul><hr><h2 id="🔧-栗子" tabindex="-1">🔧 栗子 <a class="header-anchor" href="#🔧-栗子" aria-label="Permalink to “🔧 栗子”">​</a></h2><p><strong>App：</strong> 作为被桥接的接口，提供功能</p><p><strong>Ali 和 Tencent：</strong> 作为被桥接接口的实现，实现功能</p><p><strong>Phone：</strong> 作为桥接器，引用APP并提供基本操作</p><p><strong>OPPO 和 VIVO：</strong> 作为实现Phone的实现类</p><h2 id="✅-优点" tabindex="-1">✅ 优点 <a class="header-anchor" href="#✅-优点" aria-label="Permalink to “✅ 优点”">​</a></h2><p>显而易见，我们不需要花很多时间去创建过多的子类，只需要在桥接器创建的时候引用抽象的接口就可以了，相当于将抽象和实现分开，提高灵活性</p>',17)])])}const c=t(i,[["render",s]]);export{d as __pageData,c as default};
