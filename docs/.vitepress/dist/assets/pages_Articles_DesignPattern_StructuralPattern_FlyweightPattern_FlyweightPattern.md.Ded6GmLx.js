import{_ as t,c as e,o as r,aj as n}from"./chunks/framework.iQ8U7nGd.js";const d=JSON.parse('{"title":"享元模式","description":"","frontmatter":{},"headers":[],"relativePath":"pages/Articles/DesignPattern/StructuralPattern/FlyweightPattern/FlyweightPattern.md","filePath":"pages/Articles/DesignPattern/StructuralPattern/FlyweightPattern/FlyweightPattern.md","lastUpdated":1770565939000}'),i={name:"pages/Articles/DesignPattern/StructuralPattern/FlyweightPattern/FlyweightPattern.md"};function s(l,a,h,o,g,p){return r(),e("div",null,[...a[0]||(a[0]=[n('<h1 id="享元模式" tabindex="-1">享元模式 <a class="header-anchor" href="#享元模式" aria-label="Permalink to “享元模式”">​</a></h1><p><a href="https://github.com/BanXiaNa/DesignPattern/tree/master/DesignPattern/StructuralPattern/FlyweightPattern" target="_blank" rel="noreferrer"><img src="https://img.shields.io/badge/GitHub-%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0-181717?style=flat-square&amp;logo=github" alt="GitHub"></a><a href="https://github.com/BanXiaNa/DesignPattern/tree/master/DesignPattern/StructuralPattern/FlyweightPattern" target="_blank" rel="noreferrer"><img src="https://img.shields.io/badge/Java-%E5%AE%9E%E7%8E%B0%E8%AF%AD%E8%A8%80-ED8B00?style=flat-square&amp;logo=java" alt="Java"></a></p><h2 id="📖-概述" tabindex="-1">📖 概述 <a class="header-anchor" href="#📖-概述" aria-label="Permalink to “📖 概述”">​</a></h2><p><strong>概述：</strong></p><p>如果我们的系统中存在这很多相同的类，这些类的堆积可能会造成内存的溢出，我们就可以使用享元模式进行对类对象的管理。</p><p>享元就是共享元素，我们可以将一些可以重复利用的数据或者是创建/开销太大的类保存起来，谁要用就分配给谁，防止开销太大造成太大的压力</p><p>核心就是创建一个Map对象用来管理这些类，然后通过一个工厂来获取这些对象，如果有就拿出来返回，没有的就进行创建</p><h2 id="🔗-相关资源" tabindex="-1">🔗 相关资源 <a class="header-anchor" href="#🔗-相关资源" aria-label="Permalink to “🔗 相关资源”">​</a></h2><ul><li><strong>📂 <a href="https://github.com/BanXiaNa/DesignPattern/tree/master/DesignPattern/StructuralPattern/FlyweightPattern" target="_blank" rel="noreferrer">完整源码</a></strong> - 查看享元模式的完整 Java 实现</li><li><strong>📋 <a href="https://github.com/BanXiaNa/DesignPattern" target="_blank" rel="noreferrer">项目主页</a></strong> - 返回设计模式项目主页</li></ul><hr><h2 id="🔧-栗子" tabindex="-1">🔧 栗子 <a class="header-anchor" href="#🔧-栗子" aria-label="Permalink to “🔧 栗子”">​</a></h2><p><strong>GraphicsCard：</strong> 作为抽象享元，提供一个接口用于定义方法，这里采用显卡</p><p><strong>NVIDIA：</strong> 作为具体享元，实现接口，其有一定的唯一标识，这里用型号，方便后续享元工厂操作</p><p><strong>Shop：</strong> 作为享元工厂，其内部维护一个HashMap，用于将前面提到的唯一标识符作为K，将对象存储起来，需要加载这种对象的时候，需要从享元工厂中通过标识符进行获取，Map有就返回，没有就进行创建后返回</p><h2 id="✅-优点" tabindex="-1">✅ 优点 <a class="header-anchor" href="#✅-优点" aria-label="Permalink to “✅ 优点”">​</a></h2><p>显而易见，这玩意通过共享，减小了内存开销，提高了创建对象的效率</p><h2 id="⚠️-缺点" tabindex="-1">⚠️ 缺点 <a class="header-anchor" href="#⚠️-缺点" aria-label="Permalink to “⚠️ 缺点”">​</a></h2><p>处理不当可能会引发线程安全问题</p>',18)])])}const P=t(i,[["render",s]]);export{d as __pageData,P as default};
