import{_ as a,c as r,o as e,aj as n}from"./chunks/framework.iQ8U7nGd.js";const P=JSON.parse('{"title":"工厂模式","description":"","frontmatter":{},"headers":[],"relativePath":"pages/Notes/DesignPattern/CreationalPattern/FactoryPattern/FactoryPattern.md","filePath":"pages/Notes/DesignPattern/CreationalPattern/FactoryPattern/FactoryPattern.md"}'),o={name:"pages/Notes/DesignPattern/CreationalPattern/FactoryPattern/FactoryPattern.md"};function s(i,t,l,p,c,h){return e(),r("div",null,[...t[0]||(t[0]=[n('<h1 id="工厂模式" tabindex="-1">工厂模式 <a class="header-anchor" href="#工厂模式" aria-label="Permalink to “工厂模式”">​</a></h1><p><a href="https://github.com/BanXiaNa/DesignPattern/tree/master/DesignPattern/CreationalPattern/FactoryPattern" target="_blank" rel="noreferrer"><img src="https://img.shields.io/badge/GitHub-%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0-181717?style=flat-square&amp;logo=github" alt="GitHub"></a><a href="https://github.com/BanXiaNa/DesignPattern/tree/master/DesignPattern/CreationalPattern/FactoryPattern" target="_blank" rel="noreferrer"><img src="https://img.shields.io/badge/Java-%E5%AE%9E%E7%8E%B0%E8%AF%AD%E8%A8%80-ED8B00?style=flat-square&amp;logo=java" alt="Java"></a></p><h2 id="📖-概述" tabindex="-1">📖 概述 <a class="header-anchor" href="#📖-概述" aria-label="Permalink to “📖 概述”">​</a></h2><p>简而言之： 在一个项目中，创建同一个类的代码可能均匀地分布在很多类中，如果这个类发生了改变，比如入参改变，我们就需要更改每一个创建类的代码，麻烦而且不优雅。 所以就可以创建一个专门创建别的类的类，我们把这个类称之为工厂类。</p><h2 id="🔗-相关资源" tabindex="-1">🔗 相关资源 <a class="header-anchor" href="#🔗-相关资源" aria-label="Permalink to “🔗 相关资源”">​</a></h2><ul><li><strong>📂 <a href="https://github.com/BanXiaNa/DesignPattern/tree/master/DesignPattern/CreationalPattern/FactoryPattern" target="_blank" rel="noreferrer">完整源码</a></strong> - 查看工厂模式的完整 Java 实现</li><li><strong>📋 <a href="https://github.com/BanXiaNa/DesignPattern" target="_blank" rel="noreferrer">项目主页</a></strong> - 返回设计模式项目主页</li></ul><hr><h2 id="🏭-简单工厂模式-simple-factory-pattern" tabindex="-1">🏭 简单工厂模式 [Simple Factory Pattern] <a class="header-anchor" href="#🏭-简单工厂模式-simple-factory-pattern" aria-label="Permalink to “🏭 简单工厂模式 [Simple Factory Pattern]”">​</a></h2><p><strong>概述：</strong> 我们要创建奖品的对象，有三个奖品，就可以创建一个奖品工厂来专门创建这三个奖品的对象</p><p><strong>栗子：</strong> 奖品对象：po 下的三个类，他们都实现Prize接口 简单工厂类： factory下的类</p><p><strong>问题：</strong> 如果我们要添加一个四等奖，我们就必须修改工厂类，这很显然是不健康的，违背了开闭原则。下面的工厂方法模式就可以解决这个问题</p><h2 id="⚙️-工厂方法模式-factory-method-pattern" tabindex="-1">⚙️ 工厂方法模式 [Factory Method Pattern] <a class="header-anchor" href="#⚙️-工厂方法模式-factory-method-pattern" aria-label="Permalink to “⚙️ 工厂方法模式 [Factory Method Pattern]”">​</a></h2><p><strong>概述：</strong> 通过创建一个工厂的接口，提供一个创建具体对象的方法，让子类决定创建什么产品实例。</p><p><strong>栗子：</strong> 奖品对象：我们创建了两种奖品对象，分别是CCPC奖品和ICPC奖品 工厂类：我们创建了CCPC奖品工厂和ICPC奖品工厂，他们都实现的奖品工厂接口，并实现创建具体奖品对象的方法</p><p><strong>好处：</strong> 这样要创建新的类的时候，就不需要修改工厂类，只需要创建新的工厂类，就可以创建新的奖品对象了</p><p><strong>问题：</strong> 如果我们要颁发CCPC的奖品，我们就创建一个CCPC的工厂，但是如果我们的工厂因为不可抗力发生变化了，我们的使用者也会跟着发生变化，这显然不优雅，抽象工厂方式可以解决这个问题</p><h2 id="🏗️-抽象工厂模式-abstract-factory-pattern" tabindex="-1">🏗️ 抽象工厂模式 [Abstract Factory Pattern] <a class="header-anchor" href="#🏗️-抽象工厂模式-abstract-factory-pattern" aria-label="Permalink to “🏗️ 抽象工厂模式 [Abstract Factory Pattern]”">​</a></h2><p><strong>概述：</strong> 定义一个接口用于创建工厂，然后通过挑选工厂去创建对应的类</p><p><strong>栗子：</strong> 奖品对象：我们在po目录下创建了两个产品族，ACM文件夹下有ACM的一等奖、二等奖、三等奖，OI文件夹下有OI的一等奖、二等奖、三等奖，它们都实现Prize接口</p><p>抽象工厂接口：IFactory接口定义了创建产品族的方法</p><p>具体工厂类：ACMFactory专门创建ACM系列的奖品，OIFactory专门创建OI系列的奖品</p><p>主工厂类：Factory类根据PrizeType的竞赛类型选择对应的具体工厂</p><p><strong>好处：</strong></p><ul><li>保证了产品族的一致性：使用ACM工厂创建的都是ACM系列产品</li><li>易于扩展产品族：要添加新的竞赛类型（如NOI、蓝桥杯），只需要创建新的产品族和对应的工厂</li><li>客户端代码与具体产品解耦：客户端只需要知道抽象工厂接口，不需要关心具体的产品实现</li></ul><p><strong>使用场景：</strong> 当系统需要创建一系列相关或相互依赖的对象时，比如不同品牌的UI组件、不同数据库的连接组件等</p><h2 id="💭-总结" tabindex="-1">💭 总结 <a class="header-anchor" href="#💭-总结" aria-label="Permalink to “💭 总结”">​</a></h2><p>说实话这玩意真复杂，但是思想就是这么个思想 可以搭配Spring的自动装配，把工厂放到一个Map里面，通过一个另外的工厂类导出来就可以用了</p>',27)])])}const d=a(o,[["render",s]]);export{P as __pageData,d as default};
