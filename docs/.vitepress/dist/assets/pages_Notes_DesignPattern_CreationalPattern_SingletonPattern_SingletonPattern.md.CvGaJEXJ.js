import{_ as t,c as e,o as n,aj as r}from"./chunks/framework.iQ8U7nGd.js";const d=JSON.parse('{"title":"单例模式","description":"","frontmatter":{},"headers":[],"relativePath":"pages/Notes/DesignPattern/CreationalPattern/SingletonPattern/SingletonPattern.md","filePath":"pages/Notes/DesignPattern/CreationalPattern/SingletonPattern/SingletonPattern.md"}'),i={name:"pages/Notes/DesignPattern/CreationalPattern/SingletonPattern/SingletonPattern.md"};function o(s,a,l,g,h,p){return n(),e("div",null,[...a[0]||(a[0]=[r('<h1 id="单例模式" tabindex="-1">单例模式 <a class="header-anchor" href="#单例模式" aria-label="Permalink to “单例模式”">​</a></h1><p><a href="https://github.com/BanXiaNa/DesignPattern/tree/master/DesignPattern/CreationalPattern/SingletonPattern" target="_blank" rel="noreferrer"><img src="https://img.shields.io/badge/GitHub-%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0-181717?style=flat-square&amp;logo=github" alt="GitHub"></a><a href="https://github.com/BanXiaNa/DesignPattern/tree/master/DesignPattern/CreationalPattern/SingletonPattern" target="_blank" rel="noreferrer"><img src="https://img.shields.io/badge/Java-%E5%AE%9E%E7%8E%B0%E8%AF%AD%E8%A8%80-ED8B00?style=flat-square&amp;logo=java" alt="Java"></a></p><h2 id="📖-概述" tabindex="-1">📖 概述 <a class="header-anchor" href="#📖-概述" aria-label="Permalink to “📖 概述”">​</a></h2><p>有时候我们会有一个提供管理的类，作为工具的类，提供服务的类，这些类我们在使用的时候不需要创建多个，因为会浪费内存，并且我们创建的这一堆类并没有什么不同。 这个时候，我们希望这个类全局只有一个，并且可以访问，就可以用到单例模式了。</p><h2 id="🔗-相关资源" tabindex="-1">🔗 相关资源 <a class="header-anchor" href="#🔗-相关资源" aria-label="Permalink to “🔗 相关资源”">​</a></h2><ul><li><strong>📂 <a href="https://github.com/BanXiaNa/DesignPattern/tree/master/DesignPattern/CreationalPattern/SingletonPattern" target="_blank" rel="noreferrer">完整源码</a></strong> - 查看单例模式的完整 Java 实现</li><li><strong>📋 <a href="https://github.com/BanXiaNa/DesignPattern" target="_blank" rel="noreferrer">项目主页</a></strong> - 返回设计模式项目主页</li></ul><hr><h2 id="🍽️-饿汉单例" tabindex="-1">🍽️ 饿汉单例 <a class="header-anchor" href="#🍽️-饿汉单例" aria-label="Permalink to “🍽️ 饿汉单例”">​</a></h2><p><strong>概述：</strong> 我们可以在程序加载的时候就创建这个实例，随用随到</p><p><strong>栗子：</strong> HungerSingleton：懒汉单例，私有化一个构造函数，使其不能被创建，然后提供一个静态方法，返回一个实例</p><p><strong>问题：</strong> 程序启动的时候加载示例，如果没有被使用，那么就会造成内存的浪费，所以我们可以随用随加载，这就是懒汉实例</p><h2 id="😴-懒汉单例-线程不安全" tabindex="-1">😴 懒汉单例 线程不安全 <a class="header-anchor" href="#😴-懒汉单例-线程不安全" aria-label="Permalink to “😴 懒汉单例 线程不安全”">​</a></h2><p><strong>概述：</strong> 我们在第一次使用时创建这个实例，而不是在程序启动的时候就创建</p><p><strong>栗子：</strong> LazySingletonUnsafe：一开始不创建对应的实例，而是在调用getInstance的时候创建</p><p><strong>问题：</strong> 如你所见，饿汉的 getInstance 方法是原子化的，所以线程安全 懒汉的 getInstance 方法有两个问题： 第一是if的逻辑不是原子的 第二是new可能会被JVM重排，可能会访问到没有分配的空间 线程不安全，多个线程可能会创建多个实例，就会出问题</p><h2 id="🔒-懒汉单例-线程安全" tabindex="-1">🔒 懒汉单例 线程安全 <a class="header-anchor" href="#🔒-懒汉单例-线程安全" aria-label="Permalink to “🔒 懒汉单例 线程安全”">​</a></h2><p><strong>概述：</strong> 解决if不是原子性的方法比较简单，加个锁：synchronized 注意，这个synchronized不能直接加在方法上，因为会降低性能，需要加在里面，具体可以看栗子 解决new排序的问题也很简单，加个 volatile</p><p><strong>栗子：</strong> LazySingletonSafe：线程安全 使用 synchronized 加载方法上固然简单，但是每次调用这个方法就进行一次加锁解锁，太耗费性能，效率不高，我们可以把他写在方法的if内部，也就是仅仅对创建对象的语句进行加锁 在具体点可以看代码</p><h2 id="💡-实现要点" tabindex="-1">💡 实现要点 <a class="header-anchor" href="#💡-实现要点" aria-label="Permalink to “💡 实现要点”">​</a></h2><ul><li><strong>双重检查锁定</strong>：既保证线程安全，又提高性能</li><li><strong>volatile 关键字</strong>：防止指令重排序</li><li><strong>私有构造函数</strong>：防止外部直接实例化</li><li><strong>静态内部类</strong>：另一种优雅的懒加载实现方式</li></ul>',20)])])}const P=t(i,[["render",o]]);export{d as __pageData,P as default};
