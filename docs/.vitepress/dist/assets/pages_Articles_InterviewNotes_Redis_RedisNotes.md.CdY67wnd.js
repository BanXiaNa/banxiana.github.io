import{_ as r,c as s,o as i,aj as t,j as a,a as d,t as l}from"./chunks/framework.iQ8U7nGd.js";const D=JSON.parse('{"title":"Redis 笔记","description":"","frontmatter":{},"headers":[],"relativePath":"pages/Articles/InterviewNotes/Redis/RedisNotes.md","filePath":"pages/Articles/InterviewNotes/Redis/RedisNotes.md","lastUpdated":0}'),o={name:"pages/Articles/InterviewNotes/Redis/RedisNotes.md"};function n(h,e,R,p,b,c){return i(),s("div",null,[e[1]||(e[1]=t('<h1 id="redis-笔记" tabindex="-1">Redis 笔记 <a class="header-anchor" href="#redis-笔记" aria-label="Permalink to “Redis 笔记”">​</a></h1><h2 id="redis-在生成-rdb-文件时如何处理请求" tabindex="-1">Redis 在生成 RDB 文件时如何处理请求？ <a class="header-anchor" href="#redis-在生成-rdb-文件时如何处理请求" aria-label="Permalink to “Redis 在生成 RDB 文件时如何处理请求？”">​</a></h2><p>RDB 产生自主线程发送的 bgsave 由fork出的子线程执行，主线程会将内存页表复制给子线程一份，子线程通过这个复制品来制作 RDB，写入磁盘，主线程仍然处理用户请求</p><h2 id="生成-rdb-文件的时候如何保证一致性" tabindex="-1">生成 RDB 文件的时候如何保证一致性？ <a class="header-anchor" href="#生成-rdb-文件的时候如何保证一致性" aria-label="Permalink to “生成 RDB 文件的时候如何保证一致性？”">​</a></h2><p>主线程在 fork 子线程的时候并不是去复制一份完整的内存数据给子线程，这样太浪费空间而且太慢，主线程会复制一份页表给子线程，子线程通过这个页表去遍历内存，还是共享一块内存</p><p>但是这样，主线程改，子线程读，还是会被污染，Redis 采用了写时复制技术，如果有写入操作，就复制一份当前内存页的副本出来，主线程在副本上更改，子线程去读旧的内存页，这样效率高，而且也能保证数据就是 fork 那一瞬间的数据，不会被后续操作污染</p><h2 id="高峰期使用-rdb-有什么问题-如何优化" tabindex="-1">高峰期使用 RDB 有什么问题？如何优化？ <a class="header-anchor" href="#高峰期使用-rdb-有什么问题-如何优化" aria-label="Permalink to “高峰期使用 RDB 有什么问题？如何优化？”">​</a></h2><ul><li>首先 RDB 期间，主线程采用写时复制进行写入，极端情况下会造成内存翻倍占用</li><li>子线程需要将 RDB 文件写入磁盘，如果缓存数据集很大，写入磁盘的时间相当客观，坏情况数分钟不止，磁盘IO跑满，会影响其他的AOF 和其他业务</li><li>fork 子线程的时候主线程也会阻塞，虽然是复制的内存页表，但是在数据量很大的情况下，内存页的大小也相当可观，阻塞时间可能得几十毫秒甚至上百毫秒，这个时候，主线程是不能去工作的</li></ul><p>所以一般会去设置 RDB 的时间为低峰时段跑，或者用从节点跑RDB，不耽误主节点处理请求</p><h2 id="fork-的时候为什么会阻塞主进程-不是说只复制页表吗" tabindex="-1">fork 的时候为什么会阻塞主进程？不是说只复制页表吗？ <a class="header-anchor" href="#fork-的时候为什么会阻塞主进程-不是说只复制页表吗" aria-label="Permalink to “fork 的时候为什么会阻塞主进程？不是说只复制页表吗？”">​</a></h2><p>复制页表也是需要时间的，fork 期间会被阻塞，Redis 使用虚拟内存，每个内存页通常有 4kb，如果一个有 20G 的实例去做 RDB，主线程需要去复制一个差不多几十MB的页表，差不多需要消耗100毫秒了</p><h2 id="如果-rdb-生成到一半机器挂了怎么办" tabindex="-1">如果 RDB 生成到一半机器挂了怎么办？ <a class="header-anchor" href="#如果-rdb-生成到一半机器挂了怎么办" aria-label="Permalink to “如果 RDB 生成到一半机器挂了怎么办？”">​</a></h2><p>挂了就挂了，并不会造成很大的损失，RDB 操作是先写一份临时的 RDB 文件，然后再由 rename 操作转正为 dump.rdb，rename 是原子性的，如果失败了，就还是去恢复上一次的 RDB 文件。</p><h2 id="bgsave-和-save-有什么区别-生产上用哪个" tabindex="-1">bgsave 和 save 有什么区别？生产上用哪个？ <a class="header-anchor" href="#bgsave-和-save-有什么区别-生产上用哪个" aria-label="Permalink to “bgsave 和 save 有什么区别？生产上用哪个？”">​</a></h2><p>save 是同步操作，主线程去做备份，期间完全阻塞，bgsave 是交给子线程的，异步操作，生产要用 bgsave，主线程阻塞带来的服务关停是不可承受的</p>',15)),a("p",null,[e[0]||(e[0]=a("strong",null,"最后更新时间",-1)),d("："+l(new Date().toLocaleDateString("zh-CN")),1)])])}const B=r(o,[["render",n]]);export{D as __pageData,B as default};
