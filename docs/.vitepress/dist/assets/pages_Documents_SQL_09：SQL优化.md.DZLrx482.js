import{_ as s,c as i,o as e,al as n}from"./chunks/framework.CbWvOqpl.js";const c=JSON.parse('{"title":"SQL优化","description":"","frontmatter":{},"headers":[],"relativePath":"pages/Documents/SQL/09：SQL优化.md","filePath":"pages/Documents/SQL/09：SQL优化.md","lastUpdated":1770833529000}'),l={name:"pages/Documents/SQL/09：SQL优化.md"};function h(t,a,r,p,k,d){return e(),i("div",null,[...a[0]||(a[0]=[n(`<h1 id="sql优化" tabindex="-1">SQL优化 <a class="header-anchor" href="#sql优化" aria-label="Permalink to “SQL优化”">​</a></h1><h2 id="插入优化" tabindex="-1">插入优化 <a class="header-anchor" href="#插入优化" aria-label="Permalink to “插入优化”">​</a></h2><h3 id="insert" tabindex="-1">insert <a class="header-anchor" href="#insert" aria-label="Permalink to “insert”">​</a></h3><h4 id="批量插入" tabindex="-1">批量插入 <a class="header-anchor" href="#批量插入" aria-label="Permalink to “批量插入”">​</a></h4><p>批量插入可以避免频繁地与数据库建立连接，用一次链接就插入大量的数据可以大大的提升效率</p><div class="language-sql"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">insert into</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 表名 [(字段1,字段2,......,字段n)] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">values</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (数据1,数据2,......,数据n)[，(数据1,数据2,......,数据n)，(数据1,数据2,......,数据n)];</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">insert</span></span></code></pre></div><hr><h4 id="手动提交事务" tabindex="-1">手动提交事务 <a class="header-anchor" href="#手动提交事务" aria-label="Permalink to “手动提交事务”">​</a></h4><p>因为每执行一条插入语句，mysql就会自动的开启一个事务，语句结束就提交事务，即使我们使用批量插入，还是会造成大量的浪费，避免这种情况，我们需要手动的开启和提交事务。</p><div class="language-sql"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">start transaction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">insert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ... ;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">insert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ... ;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">insert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ... ;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">commit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ;</span></span></code></pre></div><p>可以节省事务方面的开销</p><hr><h4 id="主键顺序插入" tabindex="-1">主键顺序插入 <a class="header-anchor" href="#主键顺序插入" aria-label="Permalink to “主键顺序插入”">​</a></h4><p>对于有主键的表格，建议按照主键的顺序插入数据</p><hr><h3 id="load" tabindex="-1">load <a class="header-anchor" href="#load" aria-label="Permalink to “load”">​</a></h3><p>对于大量数据的插入，insert就不适用了，我们可以使用load大量的去加载本地文件的数据</p><p>使用load需要对数据库进行操作：</p><div class="language-sql"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"># 客户端连接服务端 加上参数 </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">--local-infile</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MySQL </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">--local-infile -u root -p</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"># 设置全局参数 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">local-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">infile开关，开启从本地文件导入数据的开关</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">set</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> global</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> local_infile </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"># 使用load语句导入数据</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">load</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> local</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> infile </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;文件路径/文件名&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> into</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> table</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;表名&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fields terminated </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">by</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;字段分隔符&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	lines terminated </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">by</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;行分隔符&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><hr><h2 id="主键优化" tabindex="-1">主键优化 <a class="header-anchor" href="#主键优化" aria-label="Permalink to “主键优化”">​</a></h2><h3 id="数据组织方式" tabindex="-1">数据组织方式 <a class="header-anchor" href="#数据组织方式" aria-label="Permalink to “数据组织方式”">​</a></h3><p>表数据都是根据主键顺序存放的，这种存储结构叫做索引组织表</p><p>因为聚集索引的默认索引是主键索引，索引下挂的数据是行数据</p><hr><h3 id="页分裂-页合并" tabindex="-1">页分裂&amp;页合并 <a class="header-anchor" href="#页分裂-页合并" aria-label="Permalink to “页分裂&amp;页合并”">​</a></h3><p>数据按照主键存储，如果插入或者删除不是顺序的，为了维护数据表，就会调用这两个操作，会造成性能损耗。</p><hr><h3 id="设计原则" tabindex="-1">设计原则： <a class="header-anchor" href="#设计原则" aria-label="Permalink to “设计原则：”">​</a></h3><p>1：尽量降低主键的长度 2：主键尽量顺序插入，避免出现页分裂的情况 3：尽量不使用UUID作为主键，如身份证号 4：业务尽量避免对主键的修改，因为维护索引会造成大量的性能开支</p><hr><h2 id="order-by-优化" tabindex="-1">order by 优化 <a class="header-anchor" href="#order-by-优化" aria-label="Permalink to “order by 优化”">​</a></h2><p>首先，排序分为两种排序操作：using filesort 和 using Index</p><p><strong>using filesort</strong>：通过索引或者全表扫描，获取到数据之后，在缓冲区sort Buffer 中完成排序操作。不是通过索引直接读取到排好序的数据都叫做filesort排序</p><p><strong>using Index</strong>：很显然，直接诶读取到排好序的数据的操作叫做Index排序，操作效率高</p><h3 id="设计原则-1" tabindex="-1">设计原则： <a class="header-anchor" href="#设计原则-1" aria-label="Permalink to “设计原则：”">​</a></h3><p>1：根据排序的字段建立适合的索引 2：尽量使用覆盖索引 3：注意创建的规则细节（asc/ desc） 4：不可避免出现filesort时，可以调节缓冲区大小，默认为256k</p><hr><h2 id="group-by-优化" tabindex="-1">group by 优化 <a class="header-anchor" href="#group-by-优化" aria-label="Permalink to “group by 优化”">​</a></h2><p>好像也没什么注意的，就是要建立联合索引，满足最左前缀法则之类的</p><hr><h2 id="limit-分页查询-优化" tabindex="-1">limit 分页查询 优化 <a class="header-anchor" href="#limit-分页查询-优化" aria-label="Permalink to “limit 分页查询 优化”">​</a></h2><p>因为数据结构是B+树的原因，分页查询如果页数比较靠后，就会从开头进行遍历操作，相当浪费时间。</p><p>可以创建覆盖索引，通过联合查询或者子查询来解决问题</p><hr><h2 id="count优化" tabindex="-1">count优化 <a class="header-anchor" href="#count优化" aria-label="Permalink to “count优化”">​</a></h2><p>这个对于不同的引擎，count的效率也会不同 <strong>MyISAM</strong> 引擎把一个表的总行数存在了磁盘上，count( * )会直接返回 <strong>InnoDb</strong> 引擎执行count( * )会把表的所有数据读取出来，然后计数</p><p>count原理：count会对结果集进行一步步地判断，如果结果不是null，累计值就加一，最后返回累计值</p><p>count( * )：数据库做了优化，不会取出一行行的数据，所以尽量使用 count( * )</p><hr><h2 id="update优化" tabindex="-1">update优化 <a class="header-anchor" href="#update优化" aria-label="Permalink to “update优化”">​</a></h2><p>update在更新数据的时候，为了数据的安全，会对数据进行加锁操作。 数据的加锁操作是根据索引添加的行锁，如果索引失效，就会升级为表锁 如果更新数据的条件可以调用索引查找到，就只对当前行进行加行锁，如果条件不能够用索引查询，就只能对整张表进行加锁，此时，数据库的并发性能就会大大降低。 因此，数据库在更新数据时，筛选条件应该尽量依靠索引，避免行锁升级为表锁。</p><hr><h1 id="" tabindex="-1"><a class="header-anchor" href="#" aria-label="Permalink to “”">​</a></h1>`,54)])])}const g=s(l,[["render",h]]);export{c as __pageData,g as default};
