import{_ as e,c as l,o as r,al as h}from"./chunks/framework.CbWvOqpl.js";const T=JSON.parse('{"title":"Java 并发笔记","description":"","frontmatter":{},"headers":[],"relativePath":"pages/Articles/InterviewNotes/Java/JavaConcurrency/JavaConcurrency.md","filePath":"pages/Articles/InterviewNotes/Java/JavaConcurrency/JavaConcurrency.md","lastUpdated":1771093105000}'),t={name:"pages/Articles/InterviewNotes/Java/JavaConcurrency/JavaConcurrency.md"};function d(o,a,i,c,n,p){return r(),l("div",null,[...a[0]||(a[0]=[h('<h1 id="java-并发笔记" tabindex="-1">Java 并发笔记 <a class="header-anchor" href="#java-并发笔记" aria-label="Permalink to “Java 并发笔记”">​</a></h1><h2 id="什么是-java-的-cas-compare-and-swap-操作" tabindex="-1">什么是 Java 的 CAS（Compare-And-Swap）操作？ <a class="header-anchor" href="#什么是-java-的-cas-compare-and-swap-操作" aria-label="Permalink to “什么是 Java 的 CAS（Compare-And-Swap）操作？”">​</a></h2><p>CAS 是并发操作的基石，是一种原子操作，他会检测目标内存是否是预期值，如果是的话就更改为新值，如果不是的话就自旋重试</p><p>这种操作优势很明显，他不需要做加锁这种开销大的操作就能保证线程安全，缺点也很明显：</p><ul><li>ABA问题：如果一个A值被修改成了B，然后又被改成了A，这时候再去操作是发现不了的，因为值已经变回去了，但是确是被操作过的</li><li>自旋开销：在搞并发情况下，自旋会发生的比较频繁，CPU的开销比较大</li><li>只能保证单个变量操作的原子性，多个不能保证</li></ul><h2 id="aba问题是什么-怎么避免的" tabindex="-1">ABA问题是什么，怎么避免的？ <a class="header-anchor" href="#aba问题是什么-怎么避免的" aria-label="Permalink to “ABA问题是什么，怎么避免的？”">​</a></h2><p>ABA 问题是 CAS 在并发的时候遇到的常见问题，具体来说就是一个变量从A变成B再变为A，CAS无法检测到这种变化，误以为是原值，然后产生错误操作的情况</p><p>常用解决思路是引入版本号，这样即使值相同，也会因为版本号的不同区分出来。</p><h2 id="atomiclong-是什么-干什么用的" tabindex="-1">AtomicLong 是什么？干什么用的？ <a class="header-anchor" href="#atomiclong-是什么-干什么用的" aria-label="Permalink to “AtomicLong 是什么？干什么用的？”">​</a></h2><p>AtomicLong 简单来说就是一个支持原子操作的 Long 类型</p><p>首先，普通的Long会有两个致命问题：</p><ul><li>累加并非原子性操作：普通的Long的累加操作（++）分为三个步骤，读取，+1，写回。很显然不能保证线程安全</li><li>撕裂问题：普通的Long是64位的，写入操作也是分为两部分：高32位和低32位写入，这两个步骤是分开的，如果中间有线程进来读一下，就会读到错误的数据</li></ul><p>AtomicLong 解决了这两个问题，使用 Unsafe + CAS 保证了操作的原子性和数据可见性</p><p>也就是说对于 ++操作：获取值，+1，CAS（查询内存，看看是否和旧值相同，如果相同就更新，如果不同就重试）这样就能保证安全</p><p>但是这种实现方式对于极高并发场景下会出现性能抖动：会出现大量等待的线程在自旋，这会消耗掉大部分的性能，无所谓，后面会有 <strong>LongAdder</strong> 和 <strong>DoubleAdder</strong> 出手</p><h2 id="你使用过-java-的累加器吗" tabindex="-1">你使用过 Java 的累加器吗？ <a class="header-anchor" href="#你使用过-java-的累加器吗" aria-label="Permalink to “你使用过 Java 的累加器吗？”">​</a></h2><p>累加器常用的就是 LongAdder 和 DoubleAdder，相对于 Atomic，他解决了高并发下线程都在自旋的问题。</p><p>LongAdder 选择不去让线程去抢占一个变量的使用权，而是维护了一个 BaseCount 变量和一个 Cell 数组，在竞争不激烈的时候，线程会去更改 BaseCount 的值达到修改的目的，反之会在 Cell 数组找一块地方进行更新，统计的时候将所有的值加起来就行</p><h2 id="longadder-采用的-cell-数组是怎么样的-讲一讲" tabindex="-1">LongAdder 采用的 Cell 数组是怎么样的？讲一讲？ <a class="header-anchor" href="#longadder-采用的-cell-数组是怎么样的-讲一讲" aria-label="Permalink to “LongAdder 采用的 Cell 数组是怎么样的？讲一讲？”">​</a></h2><p>Cell 数组是用于防止并发场景下大家都去更新一个变量做出的缓和操作，具体来说是如果更新变量失败，就会去这个数组中找一个地方去更新，保证并发性</p><p>这个数组一开始不会创建好，只有 BaseCount 访问失败的时候才会去创建，初始长度是二，如果之后还是不够，还会触发扩容，但是不会超过CPU的核心数，因为同一时间执行的线程就这么多，过了就没意义了</p><p>另外，其用 Contended 保证不出现伪共享</p><h2 id="java-中的-threadlocal-是如何实现线程资源隔离的" tabindex="-1">Java 中的 ThreadLocal 是如何实现线程资源隔离的？ <a class="header-anchor" href="#java-中的-threadlocal-是如何实现线程资源隔离的" aria-label="Permalink to “Java 中的 ThreadLocal 是如何实现线程资源隔离的？”">​</a></h2><p>简单来说，ThreadLocal 让每个线程拥有自己的资源，每个 Thread 中有一个 Map：ThreadLocalMap，叫做threadLocals，用来存放自己的资源。<code>threadLocal.get()</code>方法本质上就是让这个线程去自己的 ThreadLocalMap 中去找，找到了拿来用。</p><h2 id="你说-entry-的-key-是弱引用-那为什么不把-value-也设计成弱引用-这样不就不会内存泄漏了" tabindex="-1">你说 Entry 的 key 是弱引用，那为什么不把 value 也设计成弱引用，这样不就不会内存泄漏了？ <a class="header-anchor" href="#你说-entry-的-key-是弱引用-那为什么不把-value-也设计成弱引用-这样不就不会内存泄漏了" aria-label="Permalink to “你说 Entry 的 key 是弱引用，那为什么不把 value 也设计成弱引用，这样不就不会内存泄漏了？”">​</a></h2><p>value 如果也弱引用，如果发生GC，就给清除了，后续就找不到数据了，ThreadLocalMap 里面的数据本来就是要给别的地方使用的，如果莫名其妙消失了，就违背了设计的初衷，所以使用者得注意 remove 的使用，防止堆积</p><h2 id="为什么-threadlocalmap-用线性探测法而不是链地址法" tabindex="-1">为什么 ThreadLocalMap 用线性探测法而不是链地址法？ <a class="header-anchor" href="#为什么-threadlocalmap-用线性探测法而不是链地址法" aria-label="Permalink to “为什么 ThreadLocalMap 用线性探测法而不是链地址法？”">​</a></h2><p>在实际开发中 ThreadLocalMap 中存放的东西数量一般很少，冲突概率不高，线性探测法简单，效率高，内存连续所以缓存友好</p><h2 id="java-中的-inheritablethreadlocal-是什么" tabindex="-1">Java 中的 InheritableThreadLocal 是什么？ <a class="header-anchor" href="#java-中的-inheritablethreadlocal-是什么" aria-label="Permalink to “Java 中的 InheritableThreadLocal 是什么？”">​</a></h2><p>InheritableThreadLocal 是 ThreadLocal 的子类，解决的是子线程继承父线程的资源问题，如果使用 ThreadLocal 作为存储，子线程就无法和父线程进行值传递，父线程设置的值子线程就拿不到，在 InheritableThreadLocal 被创建的时候，会拷贝一份父线程的值，之后父线程的更改与子线程无关</p><h2 id="inheritablethreadlocal-是怎么实现父子线程传值的" tabindex="-1">InheritableThreadLocal 是怎么实现父子线程传值的？ <a class="header-anchor" href="#inheritablethreadlocal-是怎么实现父子线程传值的" aria-label="Permalink to “InheritableThreadLocal 是怎么实现父子线程传值的？”">​</a></h2><p>inheritableThreadLocals 是除了 threadLocals 的另外一个 ThreadLocalMap 字段，在子线程被创建的时候构造函数会去扫描父线程的 inheritableThreadLocals 字段，如果里面有东西，就会把这个东西拷贝下来到子线程的 inheritableThreadLocals 中</p><p>不过这个拷贝仅仅发生在子线程刚被创建的时候，对于线程池来说，这玩意就废了，可以试一下 TransmittableThreadLocal</p><h2 id="什么是-java-的-transmittablethreadlocal" tabindex="-1">什么是 Java 的 TransmittableThreadLocal？ <a class="header-anchor" href="#什么是-java-的-transmittablethreadlocal" aria-label="Permalink to “什么是 Java 的 TransmittableThreadLocal？”">​</a></h2><p>TransmittableThreadLocal 是阿里开发的工具类，专门解决线程池中线程传递值问题。其实 Thread 提供了一种解决方案：InheritableThreadLocal，但这种传递仅仅发生在子线程刚被创建的时候，这种模式不适用于线程池，因为在任务被提交到线程池的时候，线程往往已经被创建了，压根不起作用 TransmittableThreadLocal 的工作原理就是当任务提交的时候，任务对象将主线程的 ThreadLocal 作为快照保存下来，线程池的线程执行任务的时候再将这个快照还原，执行完毕之后再清理</p><h2 id="为什么-inheritablethreadlocal-在线程池不管用" tabindex="-1">为什么 InheritableThreadLocal 在线程池不管用 <a class="header-anchor" href="#为什么-inheritablethreadlocal-在线程池不管用" aria-label="Permalink to “为什么 InheritableThreadLocal 在线程池不管用”">​</a></h2><p>InheritableThreadLocal 仅仅在创建线程的时候执行构造方法，拷贝父线程的 inheritableThreadLocals，后续提交的任务只是复用已有的线程，并不会执行构造方法，父值无法传递</p><h2 id="ttl-和-inheritablethreadlocal-能一起用吗-会有什么问题" tabindex="-1">TTL 和 InheritableThreadLocal 能一起用吗？会有什么问题？ <a class="header-anchor" href="#ttl-和-inheritablethreadlocal-能一起用吗-会有什么问题" aria-label="Permalink to “TTL 和 InheritableThreadLocal 能一起用吗？会有什么问题？”">​</a></h2><p>可以使用，TTL本身继承自 InheritableThreadLocal ，new Thread 是 InheritableThreadLocal 的机制，而线程池则是使用 TTL 的 CRR 机制，但是，如果线程池的线程是通过 new Thread 创建的，会继承父线程的 inheritableThreadLocals ，后续有任务传递会 replay 覆盖一次，两次值可能不一样，最好统一使用 TTL</p><h2 id="ttl-的-holder-用-weakhashmap-为什么能防止内存泄漏" tabindex="-1">TTL 的 holder 用 WeakHashMap 为什么能防止内存泄漏？ <a class="header-anchor" href="#ttl-的-holder-用-weakhashmap-为什么能防止内存泄漏" aria-label="Permalink to “TTL 的 holder 用 WeakHashMap 为什么能防止内存泄漏？”">​</a></h2><p>holder 的 key 是 TTL，也就是说，当外部对 TTL 的强引用消失之后，WeakHashMap 就能够清理掉这个key，对应的 Value 也会被清理掉，如果使用 HashMap，key 就不能正常回收，就会发生泄露，但是，弱引用还是兜底，及时 remove 才是好习惯</p><h2 id="为什么-java-中的-threadlocalmap-对-key-的引用为弱引用" tabindex="-1">为什么 Java 中的 ThreadLocalMap 对 key 的引用为弱引用？ <a class="header-anchor" href="#为什么-java-中的-threadlocalmap-对-key-的引用为弱引用" aria-label="Permalink to “为什么 Java 中的 ThreadLocalMap 对 key 的引用为弱引用？”">​</a></h2><p>首先要明白 每一个 Thread 中维护一个 ThreadLocalMap，ThreadLocalMap 中有一个 Entity 数组，Entity 这个东西继承了用弱引用包装的 ThreadLocal 对象，然后内部有一个 Value 变量，初始化的时候将 ThreadLocal 作为弱引用，Value作为强引用</p><p>这样一来，当栈内失去了 ThreadLocal 这个 key的时候，GC会及时回收掉没有被强引用的它，然后当 ThreadLocalMap 被操作的时候，比如查找的时候，如果发现失效的Entity，或者是扩容的时候，又会清理掉失效的 Entity，这样就完成了对内存的清理</p><p>即使是这样，也只是尽力而为，也不能保证所有的 Entity 被及时的清理，所以还是记得使用 remove 更彻底</p><h2 id="既然弱引用key会导致内存泄漏-为什么不直接用强引用然后在某个时机统一清理" tabindex="-1">既然弱引用Key会导致内存泄漏，为什么不直接用强引用然后在某个时机统一清理？ <a class="header-anchor" href="#既然弱引用key会导致内存泄漏-为什么不直接用强引用然后在某个时机统一清理" aria-label="Permalink to “既然弱引用Key会导致内存泄漏，为什么不直接用强引用然后在某个时机统一清理？”">​</a></h2><p>强引用手动清理的最大问题就是无法保证时机，万一清理完毕之后，马上又要使用刚刚被清理的 ThreadLocal，就麻烦了，其次就是，如果使用弱引用，key 是会被及时清理的，发生短暂泄露的只是 Value 罢了，即使是这样，也比强引用好得多</p><h2 id="threadlocalmap-为什么用线性探测法而不是链表法处理哈希冲突" tabindex="-1">ThreadLocalMap 为什么用线性探测法而不是链表法处理哈希冲突？ <a class="header-anchor" href="#threadlocalmap-为什么用线性探测法而不是链表法处理哈希冲突" aria-label="Permalink to “ThreadLocalMap 为什么用线性探测法而不是链表法处理哈希冲突？”">​</a></h2><p>ThreadLocalMap 在实际使用中，通常不会存放太多的值，在如此稀少的情况下，使用前者的好处就大于后者，首先就是缓存命中率高，其次就是清理过期的 Entity 的时候可以顺便整理数组</p><h2 id="如果我把-threadlocal-定义成-static-的-还会有内存泄漏问题吗" tabindex="-1">如果我把 ThreadLocal 定义成 static 的，还会有内存泄漏问题吗？ <a class="header-anchor" href="#如果我把-threadlocal-定义成-static-的-还会有内存泄漏问题吗" aria-label="Permalink to “如果我把 ThreadLocal 定义成 static 的，还会有内存泄漏问题吗？”">​</a></h2><p>static 的对象会被类加载器强引用，因此不会被回收，也就不会出现 key 为 null 的情况，也就不会发生泄露，但是如果 Value 很大，就会一直待在内存里，所以，及时 remove 才是上上策。</p><h2 id="inheritablethreadlocal-的引用设计和-threadlocal-一样吗" tabindex="-1">InheritableThreadLocal 的引用设计和 ThreadLocal 一样吗？ <a class="header-anchor" href="#inheritablethreadlocal-的引用设计和-threadlocal-一样吗" aria-label="Permalink to “InheritableThreadLocal 的引用设计和 ThreadLocal 一样吗？”">​</a></h2><p>一样的，因为 InheritableThreadLocal 继承 ThreadLocal 存放的位置还是 ThreadLocalMap，Entity 也没有被修改引用方面，区别只是当 Thread 被创建的时候，会扫描父线程的 inheritableThreadLocals，拷贝给子线程</p><h2 id="为什么不直接使用-weekhashmap-替代-threadlocalmap" tabindex="-1">为什么不直接使用 WeekHashMap 替代 ThreadLocalMap ？ <a class="header-anchor" href="#为什么不直接使用-weekhashmap-替代-threadlocalmap" aria-label="Permalink to “为什么不直接使用 WeekHashMap 替代  ThreadLocalMap ？”">​</a></h2><ul><li>性能：ThreadLocalMap 的 key 永远是 ThreadLocal，不需要处理复杂的 Key 类型，也不需要实现复杂的 equals 判断，他的哈希算法是为 ThreadLocal 量身定做的，分布更加均匀</li><li>由于实际使用中 ThreadLocal 存量比较小，使用开放寻址法更为优秀，空间利用率和缓存命中率都比较优秀</li></ul><h2 id="inheritablethreadlocal-的拷贝是深拷贝还是浅拷贝" tabindex="-1">InheritableThreadLocal 的拷贝是深拷贝还是浅拷贝？ <a class="header-anchor" href="#inheritablethreadlocal-的拷贝是深拷贝还是浅拷贝" aria-label="Permalink to “InheritableThreadLocal 的拷贝是深拷贝还是浅拷贝？”">​</a></h2><p>浅拷贝，也就是说对于可变对象，子线程拿到的也是引用，如果想改为深拷贝，可以重写 childValue 方法</p><h2 id="为什么-jdk-不直接在-threadlocal-里支持父子线程传递" tabindex="-1">为什么 JDK 不直接在 ThreadLocal 里支持父子线程传递？ <a class="header-anchor" href="#为什么-jdk-不直接在-threadlocal-里支持父子线程传递" aria-label="Permalink to “为什么 JDK 不直接在 ThreadLocal 里支持父子线程传递？”">​</a></h2><p>ThreadLocal 被发明的本意就是线程隔离，继承关系，在很多场景下是不需要的，而且如果支持的话，使用不当可能造成数据污染，所以选择单独提供一个 InheritableThreadLocal 用于继承数据</p><h2 id="transmittablethreadlocal-的性能开销大吗" tabindex="-1">TransmittableThreadLocal 的性能开销大吗？ <a class="header-anchor" href="#transmittablethreadlocal-的性能开销大吗" aria-label="Permalink to “TransmittableThreadLocal 的性能开销大吗？”">​</a></h2><p>有的有的，因为在每一次任务提交的时候都要遍历所有的 TransmittableThreadLocal 对象制作快照，任务执行的时候需要进行快照的恢复和清理，所以会有开销</p><h2 id="如果子线程修改了-inheritablethreadlocal-的值-父线程能感知到吗" tabindex="-1">如果子线程修改了 InheritableThreadLocal 的值，父线程能感知到吗？ <a class="header-anchor" href="#如果子线程修改了-inheritablethreadlocal-的值-父线程能感知到吗" aria-label="Permalink to “如果子线程修改了 InheritableThreadLocal 的值，父线程能感知到吗？”">​</a></h2><ul><li>如果子线程获得的是非引用对象，就不会感知，因为本质上是两个对象</li><li>如果获得的是引用对象，如果修改引用，则不会有感知，如果是修改的是对象的内容，则能感知到，因为 InheritableThreadLocal 使用的是浅拷贝来获取父对象的值</li></ul><h2 id="线程池场景下-inheritablethreadlocal-有什么问题" tabindex="-1">线程池场景下 InheritableThreadLocal 有什么问题？ <a class="header-anchor" href="#线程池场景下-inheritablethreadlocal-有什么问题" aria-label="Permalink to “线程池场景下 InheritableThreadLocal 有什么问题？”">​</a></h2><p>有大问题，InheritableThreadLocal 的机制是在被创建的时候去扫描父线程的 inheritableThreadLocals 字段，并拿到这里面东西的副本，后续不再访问，线程池里面的线程是提前创建好的，执行任务时所用的线程只是对线程池中线程的复用，并不会达到继承当时父线程数据的效果，可以使用 TransmittableThreadLocal 来实现对线程池的友好</p>',65)])])}const b=e(t,[["render",d]]);export{T as __pageData,b as default};
