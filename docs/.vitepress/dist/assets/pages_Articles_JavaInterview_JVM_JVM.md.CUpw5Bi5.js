import{_ as a,c as t,o as r,aj as n}from"./chunks/framework.iQ8U7nGd.js";const p=JSON.parse('{"title":"JVM 笔记","description":"","frontmatter":{},"headers":[],"relativePath":"pages/Articles/JavaInterview/JVM/JVM.md","filePath":"pages/Articles/JavaInterview/JVM/JVM.md","lastUpdated":0}'),l={name:"pages/Articles/JavaInterview/JVM/JVM.md"};function o(c,e,i,s,f,d){return r(),t("div",null,[...e[0]||(e[0]=[n('<h1 id="jvm-笔记" tabindex="-1">JVM 笔记 <a class="header-anchor" href="#jvm-笔记" aria-label="Permalink to “JVM 笔记”">​</a></h1><h2 id="java-中的强引用、软引用、弱引用和虚引用分别是什么" tabindex="-1">Java 中的强引用、软引用、弱引用和虚引用分别是什么？ <a class="header-anchor" href="#java-中的强引用、软引用、弱引用和虚引用分别是什么" aria-label="Permalink to “Java 中的强引用、软引用、弱引用和虚引用分别是什么？”">​</a></h2><p>按照被 GC 回收的难易程度大致为 强引用 &gt; 软引用 &gt; 弱引用 &gt; 虚引用</p><ul><li>强引用：普通赋值就是强引用：<code>Object obj = new Object();</code>这个永远不会被GC回收，即使OOM！！！也不会被回收</li><li>软引用：通过 SoftReference 进行包装引用，内存足够的时候不回收，快OOM的时候才进行回收，适合做缓存</li><li>弱引用：通过 WeakReference 进行包装引用，GC总是会回收这个，WeakHashMap 的键就是用这个包装的</li><li>虚引用：通过 PhantomReference 进行包装引用，如果我们对着它使用 get，我们并不会拿到任何东西，这个东西的作用就是监控一个对象什么时候被回收</li></ul><h2 id="软引用在什么时候会被回收-是内存不足就立刻回收吗" tabindex="-1">软引用在什么时候会被回收？是内存不足就立刻回收吗？ <a class="header-anchor" href="#软引用在什么时候会被回收-是内存不足就立刻回收吗" aria-label="Permalink to “软引用在什么时候会被回收？是内存不足就立刻回收吗？”">​</a></h2><p>不是，内存充足的情况下并不会回收被 SoftReference 包装的实例，在内存吃紧，快要抛出 OOM 的时候，才会去回收被 SoftReference 包装实例，但也不是会被立刻回收，JVM实际上只是保证在抛出 OOM 的时候不会有被 SoftReference 包装的实例存于内存，至于什么时候回收，HotSpot 有个 <code>-XX:SoftRefLRUPolicyMSPerMB</code> 参数，默认 1000，也就是，每有1MB空闲内存，软引用可以多活一秒，相应的，内存越少，软引用在内存中存活的时间越短，所以应该是内存不足，对 SoftReference 包装的实例的回收操作变的越积极</p><h2 id="为什么-phantomreference-的-get-方法永远返回-null" tabindex="-1">为什么 PhantomReference 的 get() 方法永远返回 null？ <a class="header-anchor" href="#为什么-phantomreference-的-get-方法永远返回-null" aria-label="Permalink to “为什么 PhantomReference 的 get() 方法永远返回 null？”">​</a></h2><p>因为虚引用的目的就是监控对象被回收的时机，这个对象就是用来被回收的，如果可以再次获取这个对象，就意味这个对象可以被复活，这样就违背了虚引用的目的</p>',8)])])}const _=a(l,[["render",o]]);export{p as __pageData,_ as default};
