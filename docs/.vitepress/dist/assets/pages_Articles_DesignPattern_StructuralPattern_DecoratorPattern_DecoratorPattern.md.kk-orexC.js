import{_ as a,c as r,o as e,al as n}from"./chunks/framework.CbWvOqpl.js";const d=JSON.parse('{"title":"装饰器模式","description":"","frontmatter":{},"headers":[],"relativePath":"pages/Articles/DesignPattern/StructuralPattern/DecoratorPattern/DecoratorPattern.md","filePath":"pages/Articles/DesignPattern/StructuralPattern/DecoratorPattern/DecoratorPattern.md","lastUpdated":1770565939000}'),o={name:"pages/Articles/DesignPattern/StructuralPattern/DecoratorPattern/DecoratorPattern.md"};function l(s,t,i,h,c,g){return e(),r("div",null,[...t[0]||(t[0]=[n('<h1 id="装饰器模式" tabindex="-1">装饰器模式 <a class="header-anchor" href="#装饰器模式" aria-label="Permalink to “装饰器模式”">​</a></h1><p><a href="https://github.com/BanXiaNa/DesignPattern/tree/master/DesignPattern/StructuralPattern/DecoratorPattern" target="_blank" rel="noreferrer"><img src="https://img.shields.io/badge/GitHub-%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0-181717?style=flat-square&amp;logo=github" alt="GitHub"></a><a href="https://github.com/BanXiaNa/DesignPattern/tree/master/DesignPattern/StructuralPattern/DecoratorPattern" target="_blank" rel="noreferrer"><img src="https://img.shields.io/badge/Java-%E5%AE%9E%E7%8E%B0%E8%AF%AD%E8%A8%80-ED8B00?style=flat-square&amp;logo=java" alt="Java"></a></p><h2 id="📖-概述" tabindex="-1">📖 概述 <a class="header-anchor" href="#📖-概述" aria-label="Permalink to “📖 概述”">​</a></h2><p><strong>概述：</strong></p><blockquote><p>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。 装饰器模式通过将对象包装在装饰器类中，以便动态地修改其行为。 这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。</p></blockquote><h2 id="🔗-相关资源" tabindex="-1">🔗 相关资源 <a class="header-anchor" href="#🔗-相关资源" aria-label="Permalink to “🔗 相关资源”">​</a></h2><ul><li><strong>📂 <a href="https://github.com/BanXiaNa/DesignPattern/tree/master/DesignPattern/StructuralPattern/DecoratorPattern" target="_blank" rel="noreferrer">完整源码</a></strong> - 查看装饰器模式的完整 Java 实现</li><li><strong>📋 <a href="https://github.com/BanXiaNa/DesignPattern" target="_blank" rel="noreferrer">项目主页</a></strong> - 返回设计模式项目主页</li></ul><hr><h2 id="🎯-场景" tabindex="-1">🎯 场景 <a class="header-anchor" href="#🎯-场景" aria-label="Permalink to “🎯 场景”">​</a></h2><p>需要通过创建大量子类来扩展类的功能的时候，比如，我们有手机类，然后还想给手机加个壳子的功能，我们就需要创建手机类的数目*壳子类的数目的类才能完成这个工作</p><p>需要动态的添加或者撤销对象功能的时候</p><h2 id="🏗️-结构" tabindex="-1">🏗️ 结构 <a class="header-anchor" href="#🏗️-结构" aria-label="Permalink to “🏗️ 结构”">​</a></h2><p><strong>原来类的接口：</strong> Component</p><p><strong>原来类：</strong> Concrete Component</p><p><strong>抽象装饰器：</strong> Decorator，需要继承原来的接口</p><p><strong>具体的装饰器：</strong> Concrete Decorator：在继承的同时添加功能，在被装饰类被触发前/后触发</p><h2 id="🔧-栗子" tabindex="-1">🔧 栗子 <a class="header-anchor" href="#🔧-栗子" aria-label="Permalink to “🔧 栗子”">​</a></h2><p><strong>Phone：</strong> 作为原接口，定义了显示手机的价格和显示手机的功能两个方法</p><p><strong>OPPO 和 VIVO：</strong> 实现原接口，作为被装饰的类</p><p><strong>Shell：</strong> 这是一个继承了手机接口的抽象手机壳类，作为手机壳，足以装饰手机类了</p><p><strong>RedShell 和 YellowShell：</strong> 继承了Shell，增加了新功能</p><h2 id="✅-优点" tabindex="-1">✅ 优点 <a class="header-anchor" href="#✅-优点" aria-label="Permalink to “✅ 优点”">​</a></h2><ul><li><strong>低耦合</strong>：装饰类和被装饰类可以独立变化，互不影响。</li><li><strong>灵活性</strong>：可以动态地添加或撤销功能。</li><li><strong>替代继承</strong>：提供了一种继承之外的扩展对象功能的方式。</li></ul><h2 id="⚠️-缺点" tabindex="-1">⚠️ 缺点 <a class="header-anchor" href="#⚠️-缺点" aria-label="Permalink to “⚠️ 缺点”">​</a></h2><ul><li><strong>复杂性</strong>：多层装饰可能导致系统复杂性增加。</li></ul>',25)])])}const P=a(o,[["render",l]]);export{d as __pageData,P as default};
