import{_ as s,c as e,o as i,aj as n}from"./chunks/framework.iQ8U7nGd.js";const g=JSON.parse('{"title":"MySQL 学习笔记","description":"","frontmatter":{},"headers":[],"relativePath":"pages/Notes/SQL/MySQLNotes.md","filePath":"pages/Notes/SQL/MySQLNotes.md"}'),l={name:"pages/Notes/SQL/MySQLNotes.md"};function t(h,a,r,p,d,o){return i(),e("div",null,[...a[0]||(a[0]=[n(`<h1 id="mysql-学习笔记" tabindex="-1">MySQL 学习笔记 <a class="header-anchor" href="#mysql-学习笔记" aria-label="Permalink to “MySQL 学习笔记”">​</a></h1><p><a href="https://www.mysql.com/" target="_blank" rel="noreferrer"><img src="https://img.shields.io/badge/MySQL-%E6%95%B0%E6%8D%AE%E5%BA%93-4479A1?style=flat-square&amp;logo=mysql&amp;logoColor=white" alt="MySQL"></a><a href="https://www.mysql.com/" target="_blank" rel="noreferrer"><img src="https://img.shields.io/badge/SQL-%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80-CC2927?style=flat-square&amp;logo=microsoftsqlserver&amp;logoColor=white" alt="SQL"></a></p><hr><h1 id="cmd-指令" tabindex="-1">CMD 指令 <a class="header-anchor" href="#cmd-指令" aria-label="Permalink to “CMD 指令”">​</a></h1><div class="language-cmd"><button title="Copy Code" class="copy"></button><span class="lang">cmd</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mysql </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">u root </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">p</span></span></code></pre></div><hr><h1 id="sql-指令分类" tabindex="-1">SQL 指令分类 <a class="header-anchor" href="#sql-指令分类" aria-label="Permalink to “SQL 指令分类”">​</a></h1><p>​ <strong>DDL</strong>：数据定义语言，用来定义数据库对象（数据库，表，字段） ​ <strong>DML</strong>：数据操作语言，用来对数据库表的数据进行增删改 ​ <strong>DQL</strong>：数据查询语言，用来对数据库表的数据进行查询 ​ <strong>DCL</strong>：数据控制语言，用来创建用户，维护权限</p><hr><h1 id="ddl" tabindex="-1">DDL： <a class="header-anchor" href="#ddl" aria-label="Permalink to “DDL：”">​</a></h1><h2 id="查询所有数据库" tabindex="-1">查询所有数据库 <a class="header-anchor" href="#查询所有数据库" aria-label="Permalink to “查询所有数据库”">​</a></h2><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>show databases;</span></span></code></pre></div><hr><h2 id="查询使用数据库" tabindex="-1">查询使用数据库 <a class="header-anchor" href="#查询使用数据库" aria-label="Permalink to “查询使用数据库”">​</a></h2><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>select database();</span></span></code></pre></div><hr><h2 id="创建数据库" tabindex="-1">创建数据库 <a class="header-anchor" href="#创建数据库" aria-label="Permalink to “创建数据库”">​</a></h2><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>create database [if not exists] [数据库名称] [default charset 字符集] [collate 排序方式] ;</span></span></code></pre></div><p>[if not exists]：查看数据库是否存在，如果存在就创建数据库，不存在就不创建，防止数据库已经存在然后报错 [default charset 字符集]：常用字符集：utf8mb4 [collate 排序方式]：默认排序方式</p><hr><h2 id="删除数据库" tabindex="-1">删除数据库 <a class="header-anchor" href="#删除数据库" aria-label="Permalink to “删除数据库”">​</a></h2><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>drop database [if exists] 数据库名称;</span></span></code></pre></div><p>[if exists]：查询数据库是否存在，如果存在就删除，不存在就不删除，防止数据库不存在就报错</p><hr><h2 id="使用数据库" tabindex="-1">使用数据库 <a class="header-anchor" href="#使用数据库" aria-label="Permalink to “使用数据库”">​</a></h2><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>use 数据库</span></span></code></pre></div><hr><h2 id="查询表" tabindex="-1">查询表 <a class="header-anchor" href="#查询表" aria-label="Permalink to “查询表”">​</a></h2><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>show tables;</span></span></code></pre></div><hr><h2 id="创建表" tabindex="-1">创建表 <a class="header-anchor" href="#创建表" aria-label="Permalink to “创建表”">​</a></h2><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>create table 表名(</span></span>
<span class="line"><span>		字段1 字段1类型 [comment 注释],</span></span>
<span class="line"><span>		...</span></span>
<span class="line"><span>		字段n 字段n类型 [comment 注释]</span></span>
<span class="line"><span>		)[comment 注释];</span></span></code></pre></div><hr><h2 id="查询表信息" tabindex="-1">查询表信息 <a class="header-anchor" href="#查询表信息" aria-label="Permalink to “查询表信息”">​</a></h2><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>desc 表名;</span></span></code></pre></div><hr><h2 id="查询建表语句" tabindex="-1">查询建表语句 <a class="header-anchor" href="#查询建表语句" aria-label="Permalink to “查询建表语句”">​</a></h2><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>show create table 表名;</span></span></code></pre></div><hr><h2 id="修改表名" tabindex="-1">修改表名 <a class="header-anchor" href="#修改表名" aria-label="Permalink to “修改表名”">​</a></h2><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>alter table 旧表名 rename to 新表名;</span></span></code></pre></div><hr><h2 id="添加字段" tabindex="-1">添加字段 <a class="header-anchor" href="#添加字段" aria-label="Permalink to “添加字段”">​</a></h2><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>alter table 表名 add 字段名 类型 [comment 注释] [约束];</span></span></code></pre></div><hr><h2 id="修改字段数据类型" tabindex="-1">修改字段数据类型 <a class="header-anchor" href="#修改字段数据类型" aria-label="Permalink to “修改字段数据类型”">​</a></h2><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>alter table 表名 modify 字段名 类型 [comment 注释] [约束];</span></span></code></pre></div><hr><h2 id="修改字段名和数据类型" tabindex="-1">修改字段名和数据类型 <a class="header-anchor" href="#修改字段名和数据类型" aria-label="Permalink to “修改字段名和数据类型”">​</a></h2><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>alter table 表名 change 旧字段名 新字段名 类型 [comment 注释] [约束];</span></span></code></pre></div><hr><h2 id="删除表" tabindex="-1">删除表 <a class="header-anchor" href="#删除表" aria-label="Permalink to “删除表”">​</a></h2><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>drop table [if exists] 表名;</span></span></code></pre></div><hr><h2 id="格式化表" tabindex="-1">格式化表 <a class="header-anchor" href="#格式化表" aria-label="Permalink to “格式化表”">​</a></h2><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>truncate table 表名称;</span></span></code></pre></div><hr><h1 id="dml" tabindex="-1">DML： <a class="header-anchor" href="#dml" aria-label="Permalink to “DML：”">​</a></h1><h2 id="给指定字段添加数据" tabindex="-1">给指定字段添加数据 <a class="header-anchor" href="#给指定字段添加数据" aria-label="Permalink to “给指定字段添加数据”">​</a></h2><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>insert into 表名 [(字段1,字段2,......,字段n)] values (数据1,数据2,......,数据n)[，(数据1,数据2,......,数据n)，(数据1,数据2,......,数据n)];</span></span></code></pre></div><p><strong>(字段1,字段2,......,字段n)</strong>：表示给指定字段添加信息，缺省默认为所有字段。</p><p><strong>[，(数据1,数据2,......,数据n)，(数据1,数据2,......,数据n)]</strong>：表示同时添加多个数据</p><p><strong>注意</strong>：字符串和日期要用单引号括起来。</p><hr><h2 id="修改字段数据" tabindex="-1">修改字段数据 <a class="header-anchor" href="#修改字段数据" aria-label="Permalink to “修改字段数据”">​</a></h2><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>update 表名称 set 字段名称 = 新数据[,字段名称 = 新数据] where [筛选条件];</span></span></code></pre></div><p>可以修改多个字段，用逗号隔开。 筛选条件缺省默认为整张表的数据。</p><hr><h2 id="删除数据" tabindex="-1">删除数据 <a class="header-anchor" href="#删除数据" aria-label="Permalink to “删除数据”">​</a></h2><div class="language-sql"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">delete</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 表名 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [筛选条件];</span></span></code></pre></div><hr><h1 id="dql" tabindex="-1">DQL： <a class="header-anchor" href="#dql" aria-label="Permalink to “DQL：”">​</a></h1><p>查询指令较多且复杂，通过模块化来讲解。</p><hr><h2 id="基本格式" tabindex="-1">基本格式 <a class="header-anchor" href="#基本格式" aria-label="Permalink to “基本格式”">​</a></h2><p><strong>select [distinct] 字段区 from 表名称 [分组区] [排序区] [分页区] [where 判断条件];</strong></p><p><strong>distinct</strong>：去重查询</p><hr><h2 id="字段区" tabindex="-1">字段区： <a class="header-anchor" href="#字段区" aria-label="Permalink to “字段区：”">​</a></h2><h3 id="普通字段" tabindex="-1">普通字段 <a class="header-anchor" href="#普通字段" aria-label="Permalink to “普通字段”">​</a></h3><p>字段1 [[as] 别名1],字段2 [[as] 别名2],字段3 [[as] 别名3]... 字段名称可以用通配符*表示</p><h3 id="聚合函数" tabindex="-1">聚合函数 <a class="header-anchor" href="#聚合函数" aria-label="Permalink to “聚合函数”">​</a></h3><p>将字段的一列数据作为一个整体，进行纵向计算 格式：聚合函数(字段名) 计数：count 平均数：avg 最大/小：max/min 求和：sum</p><hr><h2 id="分组区" tabindex="-1">分组区 <a class="header-anchor" href="#分组区" aria-label="Permalink to “分组区”">​</a></h2><p><strong>分组查询</strong>：通过一个字段将表划分成不同的组，然后进行查询</p><p>group by 分组字段 [having 判断依据]</p><p><strong>having</strong>：判断依据：他的优先级要后于where</p><hr><h2 id="排序区" tabindex="-1">排序区 <a class="header-anchor" href="#排序区" aria-label="Permalink to “排序区”">​</a></h2><p>order by 排序依据的字段 排序规则 [,排序依据的字段 排序规则];</p><p>如果有多个排序依据，则遵循优先规则</p><h3 id="排序规则" tabindex="-1">排序规则： <a class="header-anchor" href="#排序规则" aria-label="Permalink to “排序规则：”">​</a></h3><hr><p>升序：缺省默认 asc 降序：desc</p><hr><h2 id="分页区" tabindex="-1">分页区 <a class="header-anchor" href="#分页区" aria-label="Permalink to “分页区”">​</a></h2><p>limit x,y;</p><p>x : 从第几行开始 y : 每页显示的数目</p><p>小细节 x = y*(页数-1)</p><hr><h2 id="判断条件" tabindex="-1"><strong>判断条件</strong>： <a class="header-anchor" href="#判断条件" aria-label="Permalink to “判断条件：”">​</a></h2><p>基础的运算符 区域筛选：between 小值 and 大值 精准匹配：in (值) 模糊匹配：like(&#39; _ 或者 %&#39;) 支持逻辑运算符</p><hr><h1 id="dcl" tabindex="-1">DCL： <a class="header-anchor" href="#dcl" aria-label="Permalink to “DCL：”">​</a></h1><p>用户一般存放在mysql数据库中的 user表中</p><hr><h2 id="创建用户" tabindex="-1">创建用户 <a class="header-anchor" href="#创建用户" aria-label="Permalink to “创建用户”">​</a></h2><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>create user &#39;用户名&#39;@&#39;主机名&#39; identified by &#39;密码&#39;;</span></span></code></pre></div><p>主机名通配符 % 本地主机名 localhost</p><hr><h2 id="修改密码" tabindex="-1">修改密码 <a class="header-anchor" href="#修改密码" aria-label="Permalink to “修改密码”">​</a></h2><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>alter user &#39;用户名&#39;@&#39;主机名&#39; identified with mysql_native_password by &#39;新密码&#39;;</span></span></code></pre></div><hr><h2 id="删除用户" tabindex="-1">删除用户 <a class="header-anchor" href="#删除用户" aria-label="Permalink to “删除用户”">​</a></h2><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>drop user &#39;用户名&#39;@&#39;主机名&#39;;</span></span></code></pre></div><hr><h2 id="权限" tabindex="-1">权限 <a class="header-anchor" href="#权限" aria-label="Permalink to “权限”">​</a></h2><table tabindex="0"><thead><tr><th>所有权限</th><th>all</th></tr></thead><tbody><tr><td>查询数据</td><td>select</td></tr><tr><td>插入数据</td><td>insert</td></tr><tr><td>修改数据</td><td>update</td></tr><tr><td>删除数据</td><td>delete</td></tr><tr><td>修改表</td><td>alter</td></tr><tr><td>删除数据库/表/视图</td><td>create</td></tr></tbody></table><hr><h2 id="查询权限" tabindex="-1">查询权限 <a class="header-anchor" href="#查询权限" aria-label="Permalink to “查询权限”">​</a></h2><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>show grants for &#39;用户名&#39;@&#39;主机名&#39;;</span></span></code></pre></div><hr><h2 id="授予权限" tabindex="-1">授予权限 <a class="header-anchor" href="#授予权限" aria-label="Permalink to “授予权限”">​</a></h2><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>grant all on 数据库名.表名 to &#39;用户名&#39;@&#39;主机名&#39;;</span></span></code></pre></div><hr><h2 id="撤销权限" tabindex="-1">撤销权限 <a class="header-anchor" href="#撤销权限" aria-label="Permalink to “撤销权限”">​</a></h2><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>revoke all on 数据库名.表名 from &#39;用户名&#39;@&#39;主机名&#39;;</span></span></code></pre></div><hr><h1 id="函数" tabindex="-1">函数 <a class="header-anchor" href="#函数" aria-label="Permalink to “函数”">​</a></h1><h2 id="字符串函数" tabindex="-1">字符串函数 <a class="header-anchor" href="#字符串函数" aria-label="Permalink to “字符串函数”">​</a></h2><h3 id="聚合" tabindex="-1">聚合 <a class="header-anchor" href="#聚合" aria-label="Permalink to “聚合”">​</a></h3><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>concat(&#39;字符串&#39;,&#39;字符串&#39;,&#39;字符串&#39;);</span></span></code></pre></div><p>函数可以传入多个字符串，最后输出一个字符串</p><hr><h3 id="小写" tabindex="-1">小写 <a class="header-anchor" href="#小写" aria-label="Permalink to “小写”">​</a></h3><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>lower(&#39;字符串&#39;);</span></span></code></pre></div><hr><h3 id="大写" tabindex="-1">大写 <a class="header-anchor" href="#大写" aria-label="Permalink to “大写”">​</a></h3><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>upper(&#39;字符串&#39;);</span></span></code></pre></div><hr><h3 id="左-右填充" tabindex="-1">左/右填充 <a class="header-anchor" href="#左-右填充" aria-label="Permalink to “左/右填充”">​</a></h3><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>select l(r)pad(源字符串,最终长度,填充字符串);</span></span></code></pre></div><hr><h3 id="规整字符串" tabindex="-1">规整字符串 <a class="header-anchor" href="#规整字符串" aria-label="Permalink to “规整字符串”">​</a></h3><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>select trim(字符串);</span></span></code></pre></div><hr><h3 id="输出字串" tabindex="-1">输出字串 <a class="header-anchor" href="#输出字串" aria-label="Permalink to “输出字串”">​</a></h3><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>select substring(字符串,开始位置,字串长度);</span></span></code></pre></div><p>小提示：开始位置是1</p><hr><h2 id="数值函数" tabindex="-1">数值函数： <a class="header-anchor" href="#数值函数" aria-label="Permalink to “数值函数：”">​</a></h2><h3 id="向上取整" tabindex="-1">向上取整 <a class="header-anchor" href="#向上取整" aria-label="Permalink to “向上取整”">​</a></h3><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>ceil(x);</span></span></code></pre></div><hr><h3 id="向下取整" tabindex="-1">向下取整 <a class="header-anchor" href="#向下取整" aria-label="Permalink to “向下取整”">​</a></h3><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>floor(x);</span></span></code></pre></div><hr><h3 id="取模" tabindex="-1">取模 <a class="header-anchor" href="#取模" aria-label="Permalink to “取模”">​</a></h3><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>mod(x/y);</span></span></code></pre></div><hr><h3 id="返回0-1的随机数" tabindex="-1">返回0-1的随机数 <a class="header-anchor" href="#返回0-1的随机数" aria-label="Permalink to “返回0-1的随机数”">​</a></h3><div class="language-sql"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">rand</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span></code></pre></div><hr><h3 id="返回x四舍五入的值-保留y位小数" tabindex="-1">返回x四舍五入的值，保留y位小数 <a class="header-anchor" href="#返回x四舍五入的值-保留y位小数" aria-label="Permalink to “返回x四舍五入的值，保留y位小数”">​</a></h3><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>round(x,y);</span></span></code></pre></div><hr><h2 id="日期函数" tabindex="-1">日期函数： <a class="header-anchor" href="#日期函数" aria-label="Permalink to “日期函数：”">​</a></h2><h3 id="当前日期" tabindex="-1">当前日期 <a class="header-anchor" href="#当前日期" aria-label="Permalink to “当前日期”">​</a></h3><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>curdate();</span></span></code></pre></div><hr><h3 id="当前时间" tabindex="-1">当前时间 <a class="header-anchor" href="#当前时间" aria-label="Permalink to “当前时间”">​</a></h3><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>curtime();</span></span></code></pre></div><hr><h3 id="当前日期和时间" tabindex="-1">当前日期和时间 <a class="header-anchor" href="#当前日期和时间" aria-label="Permalink to “当前日期和时间”">​</a></h3><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>now();</span></span></code></pre></div><hr><h3 id="当前date的年份" tabindex="-1">当前date的年份 <a class="header-anchor" href="#当前date的年份" aria-label="Permalink to “当前date的年份”">​</a></h3><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>year(date);</span></span></code></pre></div><hr><h3 id="当前date的月份" tabindex="-1">当前date的月份 <a class="header-anchor" href="#当前date的月份" aria-label="Permalink to “当前date的月份”">​</a></h3><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>month(date);</span></span></code></pre></div><hr><h3 id="当前date的日期" tabindex="-1">当前date的日期 <a class="header-anchor" href="#当前date的日期" aria-label="Permalink to “当前date的日期”">​</a></h3><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>day(date);</span></span></code></pre></div><h3 id="当前date之后的时间" tabindex="-1">当前date之后的时间 <a class="header-anchor" href="#当前date之后的时间" aria-label="Permalink to “当前date之后的时间”">​</a></h3><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>date_add(date,interval 数目 时间单位);</span></span></code></pre></div><p><strong>时间单位</strong>：年：year 月：month 日：day</p><hr><h3 id="起止时间差" tabindex="-1">起止时间差 <a class="header-anchor" href="#起止时间差" aria-label="Permalink to “起止时间差”">​</a></h3><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>datediff(date1,date2);</span></span></code></pre></div><hr><h2 id="流程控制函数" tabindex="-1">流程控制函数： <a class="header-anchor" href="#流程控制函数" aria-label="Permalink to “流程控制函数：”">​</a></h2><h3 id="三目运算符" tabindex="-1">三目运算符 <a class="header-anchor" href="#三目运算符" aria-label="Permalink to “三目运算符”">​</a></h3><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>if(bool,值1,值2);</span></span></code></pre></div><hr><h3 id="检测空的三目运算符" tabindex="-1">检测空的三目运算符 <a class="header-anchor" href="#检测空的三目运算符" aria-label="Permalink to “检测空的三目运算符”">​</a></h3><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>ifnull(检测字段,缺省字符串);</span></span></code></pre></div><p>如果检测的字符串为空的话，就返回缺省字符串</p><hr><h3 id="多分支语句" tabindex="-1">多分支语句 <a class="header-anchor" href="#多分支语句" aria-label="Permalink to “多分支语句”">​</a></h3><h4 id="布尔匹配型" tabindex="-1">布尔匹配型 <a class="header-anchor" href="#布尔匹配型" aria-label="Permalink to “布尔匹配型”">​</a></h4><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>case when bool then 返回字段 [when bool  then 返回字段] else 保底字段 end;</span></span></code></pre></div><p>本质就是如果bool为真，就返回相应的字段，else是都不符合就返回的保底返回字段 相当于if - else if - else 组合</p><hr><h4 id="值匹配型" tabindex="-1">值匹配型 <a class="header-anchor" href="#值匹配型" aria-label="Permalink to “值匹配型”">​</a></h4><p>case 字段</p><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>case 字段 when 检测字段 then 返回字段 [when 检测字段 then 替换字段] else 兜底字段 end;</span></span></code></pre></div><p>本质就是如果字段和检测字段相匹配的话，就返回对应的字段，else是都不符合就返回相同保底的字段 相当于Switch - case - final 语句</p><hr><h1 id="约束" tabindex="-1">约束 <a class="header-anchor" href="#约束" aria-label="Permalink to “约束”">​</a></h1><p>约束表中的字段，用于限制表中存储数据的规范 目的是保证数据存储的的规范，保证其有效</p><hr><h2 id="约束类型" tabindex="-1">约束类型： <a class="header-anchor" href="#约束类型" aria-label="Permalink to “约束类型：”">​</a></h2><table tabindex="0"><thead><tr><th>约束名</th><th>详细</th><th>字段</th></tr></thead><tbody><tr><td>非空约束</td><td>添加字段的数据不能是空的</td><td>not null</td></tr><tr><td>唯一约束</td><td>保证添加字段的数据不能重复</td><td>unique</td></tr><tr><td>默认约束</td><td>保存数据时，如果存在没指定的值，则采用默认值<br>注意：如果传递值为null的话，则不采用默认值，采用null</td><td>default</td></tr><tr><td>检查约束</td><td>保证字段的值满足一定条件</td><td>check</td></tr><tr><td>主键约束</td><td>主键是一行数据的唯一标识，有且只能存在一个</td><td>primary key</td></tr><tr><td>外键约束</td><td>用来在两张表的数据之间建立连接，保证数据的一致性</td><td>foreign key</td></tr></tbody></table><hr><h2 id="外键约束" tabindex="-1">外键约束 <a class="header-anchor" href="#外键约束" aria-label="Permalink to “外键约束”">​</a></h2><p>用来在两张表的数据之间建立连接，保证数据的一致性，完整性。 我们一般使用外键去关联主键，外键隶属主键，主键受外键制约</p><h3 id="添加外键" tabindex="-1">添加外键 <a class="header-anchor" href="#添加外键" aria-label="Permalink to “添加外键”">​</a></h3><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>alter table 外键表表名 add constraint 外键名称 foreign key (字段名) references 主表(主表字段名);</span></span></code></pre></div><p>除了用单独的指令，也可以在创建表时就指定外键：</p><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>CREATE TABLE 表名 (</span></span>
<span class="line"><span>    列1 数据类型,</span></span>
<span class="line"><span>    列2 数据类型,</span></span>
<span class="line"><span>    ...</span></span>
<span class="line"><span>    [CONSTRAINT 外键名称] FOREIGN KEY (列名) REFERENCES 另一个表名(另一个表的列名)</span></span>
<span class="line"><span>);</span></span></code></pre></div><hr><h3 id="删除外键" tabindex="-1">删除外键 <a class="header-anchor" href="#删除外键" aria-label="Permalink to “删除外键”">​</a></h3><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>alter table 外键表 drop foreign key 外键名称;</span></span></code></pre></div><hr><h2 id="外键行为" tabindex="-1">外键行为： <a class="header-anchor" href="#外键行为" aria-label="Permalink to “外键行为：”">​</a></h2><table tabindex="0"><thead><tr><th>默认行为</th><th>如果父表的主键绑定了副键，则禁止进行更改</th><th>no action / restrict</th></tr></thead><tbody><tr><td>级联行为</td><td>如果父表的主键被修改，副键也会一同被修改</td><td>cascade</td></tr><tr><td>置空行为</td><td>如果主键被删除，则副键会被置为null（如果他允许的话）</td><td>set null</td></tr><tr><td>缺省行为</td><td>主键变更，副键设为缺省值。</td><td>set default</td></tr></tbody></table><hr><h3 id="指令" tabindex="-1">指令 <a class="header-anchor" href="#指令" aria-label="Permalink to “指令”">​</a></h3><pre><code>~~~（添加外键指令）+ on update 行为 on delete 行为;
</code></pre><hr><h1 id="多表查询" tabindex="-1">多表查询 <a class="header-anchor" href="#多表查询" aria-label="Permalink to “多表查询”">​</a></h1><p>可以查询多张有关联的表结构，会产生大量的无效的笛卡尔积</p><hr><h2 id="内连接" tabindex="-1">内连接 <a class="header-anchor" href="#内连接" aria-label="Permalink to “内连接”">​</a></h2><p>分为显式内连接和隐式内连接。</p><h3 id="隐式内连接" tabindex="-1">隐式内连接 <a class="header-anchor" href="#隐式内连接" aria-label="Permalink to “隐式内连接”">​</a></h3><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>select 查询字段 from 表1,表2 where 通常是主副键的一致性;</span></span></code></pre></div><p>利用主副键的一致性进行筛选无效的笛卡尔积</p><h3 id="显式内连接" tabindex="-1">显式内连接 <a class="header-anchor" href="#显式内连接" aria-label="Permalink to “显式内连接”">​</a></h3><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>select 查询字段 from 主表 inner join 副表 on 筛选条件 where 筛选条件;</span></span></code></pre></div><hr><h2 id="外连接" tabindex="-1">外连接 <a class="header-anchor" href="#外连接" aria-label="Permalink to “外连接”">​</a></h2><p>分为左外连接和有右连接，会分别完全显示这个表的内容，即使另外一个表没有所对应的信息</p><p>左外连接：以左表为主表</p><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>select 查询字段 from 主表 left join 副表 on 筛选条件 where 筛选条件;</span></span></code></pre></div><p>右外连接：以右表为主表</p><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>select 查询字段 from 副表 right join 主表 on 筛选条件 where 筛选条件;</span></span></code></pre></div><hr><h2 id="自连接" tabindex="-1">自连接 <a class="header-anchor" href="#自连接" aria-label="Permalink to “自连接”">​</a></h2><p>自己和自己进行筛选，可以内连接，也可以外连接 select 查询字段 from 表1 别名1 , 表1 别名2 where 筛选条件;</p><hr><h2 id="联合查询" tabindex="-1">联合查询 <a class="header-anchor" href="#联合查询" aria-label="Permalink to “联合查询”">​</a></h2><p>可以塞在两个查询语句中间，使得结果进行简单的合并：union all 缺点很明显，就是这个只能进行简单的结果的叠加，不能去重，那么，怎么解决呢----去掉all 限制：所合并的查询的字段必须相同</p><hr><h2 id="子查询" tabindex="-1">子查询 <a class="header-anchor" href="#子查询" aria-label="Permalink to “子查询”">​</a></h2><p>子查询是指嵌套在其他语句中的查询语句 子查询可以嵌套在insert,update,delete,select中 根据结果不同，可以分为四类：</p><table tabindex="0"><thead><tr><th>标量子查询</th><th>子查询结果为单个的值</th></tr></thead><tbody><tr><td>列子查询</td><td>子查询结果为一列</td></tr><tr><td>行子查询</td><td>子查询结果为一行</td></tr><tr><td>表子查询</td><td>查询结果为多行多列</td></tr></tbody></table><hr><h3 id="标量子查询" tabindex="-1">标量子查询 <a class="header-anchor" href="#标量子查询" aria-label="Permalink to “标量子查询”">​</a></h3><p>用于查询查询一个数据之后的查询，可以放在where后，记得要加括号</p><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>select 字段 from 主表 where (select 字段 from *表 where 匹配条件) = 匹配条件;</span></span></code></pre></div><p>常用操作符：算数运算符进行比较</p><hr><h3 id="列子查询" tabindex="-1">列子查询 <a class="header-anchor" href="#列子查询" aria-label="Permalink to “列子查询”">​</a></h3><p>返回结果是一列 常用操作符：in，not in，any，sum，all (not) in : (不)在 any 子查询返回的列表中，有任意一个满足条件就好 some 和any一样，二者通用 all 子查询返回的所有列表值都必须全部满足</p><hr><h3 id="行子查询" tabindex="-1">行子查询 <a class="header-anchor" href="#行子查询" aria-label="Permalink to “行子查询”">​</a></h3><p>返回一行 常用操作符 = != (not)in</p><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>select 字段名 from 表名 where (字段1,字段2...字段n) = (select 字段1,字段2...字段n from 表名 where 判断条件);</span></span></code></pre></div><p>本质就是用括号将多个字段整合到一起，进行判断是否符合</p><hr><h3 id="表子查询" tabindex="-1">表子查询 <a class="header-anchor" href="#表子查询" aria-label="Permalink to “表子查询”">​</a></h3><p>主要对多行多列的表进行查询 常用操作符：in</p><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>select 字段名 from 表名 where (字段1,字段2...字段n) in (select 字段1,字段2...字段n from 表名 where 判断条件);</span></span></code></pre></div><hr><h1 id="事务" tabindex="-1">事务 <a class="header-anchor" href="#事务" aria-label="Permalink to “事务”">​</a></h1><p>定义：事务是一堆操作的集合，在操作时，一般一齐提交给系统进行处理，所以这些操作一般会一起成功或者一起失败 如果中途失败的话，就要进行事务的回滚，一般事务会默认自动提交</p><h2 id="事务操作" tabindex="-1">事务操作 <a class="header-anchor" href="#事务操作" aria-label="Permalink to “事务操作”">​</a></h2><h3 id="查看事务提交方式" tabindex="-1">查看事务提交方式 <a class="header-anchor" href="#查看事务提交方式" aria-label="Permalink to “查看事务提交方式”">​</a></h3><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>select @@autocommit;</span></span></code></pre></div><p>默认提交方式是1：自动提交 0：手动提交</p><h3 id="提交事务" tabindex="-1">提交事务 <a class="header-anchor" href="#提交事务" aria-label="Permalink to “提交事务”">​</a></h3><p>commit;</p><h3 id="回滚事务" tabindex="-1">回滚事务 <a class="header-anchor" href="#回滚事务" aria-label="Permalink to “回滚事务”">​</a></h3><p>rollback;</p><hr><h2 id="四大特性-acid" tabindex="-1">四大特性（ACID） <a class="header-anchor" href="#四大特性-acid" aria-label="Permalink to “四大特性（ACID）”">​</a></h2><p>​ 原子性：事务是不可分割的最小操作单元，要么全部成功，要么全部失败 ​ 如果执行结果不一致，就会导致数据不一致，数据库的数据就会出错 ​ 一致性：事务完成时，必须使所有数据保持一致状态 ​ 隔离性：数据库系统提供隔离特性，保证事务不受外部并发操作影响的独立环境执行 ​ 持久性：事务一旦提交或者回滚，对数据库的数据的改变就是永久的</p><hr><h2 id="并发事务问题" tabindex="-1">并发事务问题： <a class="header-anchor" href="#并发事务问题" aria-label="Permalink to “并发事务问题：”">​</a></h2><p>​ 数据库涉及数据的修改还有操作的并发，就会产生一些常见问题，常见的：脏读，不可重复读，幻读 ​ 脏读：一个事务读取到另外一个事务没有提交的数据 ​ 不可重复读：一个事务先后读取同一条记录，但读取到的数据不相同 ​ 幻读：一个事务在读取一行数据时，数据不存在，但是插入时，数据又存在了</p><hr><h2 id="事务的隔离级别" tabindex="-1">事务的隔离级别： <a class="header-anchor" href="#事务的隔离级别" aria-label="Permalink to “事务的隔离级别：”">​</a></h2><p>为了防止并发产生的问题，MYSQL设计了一系列的隔离等级 越安全的隔离方式，性能越低</p><table tabindex="0"><thead><tr><th>事务隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>read uncommitted</td><td>1</td><td>1</td><td>1</td></tr><tr><td>reda committed</td><td>0</td><td>1</td><td>1</td></tr><tr><td>repeatable read(默认)</td><td>0</td><td>0</td><td>0</td></tr><tr><td>serializable</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><p>0代表不会发生</p><p><strong>Repeatable Read</strong>：可重复读</p><p>​ 确保了在同一事务中多次读取相同记录的结果是一致的。 ​ 可以通过在读取记录时对其加锁来实现的，一旦某个事务读取了某条记录，那么在该事务完成之前，其他事务是无法修改该记录的。 ​ Mysql使用了MVCC来实现这个操作，数据在被读取时会被创建一个快照，当这个事务中的其他读取操作进行时，只能读取到当前快 照的数据，从而保证了可重复读的特性，又不会导致阻塞</p><h3 id="查看事务隔离级别" tabindex="-1">查看事务隔离级别 <a class="header-anchor" href="#查看事务隔离级别" aria-label="Permalink to “查看事务隔离级别”">​</a></h3><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>select @@transaction_isolation;</span></span></code></pre></div><h3 id="修改事务的隔离级别" tabindex="-1">修改事务的隔离级别 <a class="header-anchor" href="#修改事务的隔离级别" aria-label="Permalink to “修改事务的隔离级别”">​</a></h3><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>set 范围 transaction isolation level {read uncommitted , reda committed , repeatable read , serializable} ;</span></span></code></pre></div><p>范围：session 设置当前会话窗口 global 对全部的会话窗口有效</p><hr><h1 id="存储引擎" tabindex="-1">存储引擎 <a class="header-anchor" href="#存储引擎" aria-label="Permalink to “存储引擎”">​</a></h1><p>是存储数据，建立索引，更新，查询数据等技术的实现方式 存储引擎是基于表层次的，所以也可以算作表类型 MYSQL有很多存储引擎，不存在最好的操作引擎，各种引擎适用于不同的数据存储场合 如果在建立表的时候没有指定存储引擎，则会选择默认引擎：InnoDB</p><h2 id="指定存储引擎" tabindex="-1">指定存储引擎 <a class="header-anchor" href="#指定存储引擎" aria-label="Permalink to “指定存储引擎”">​</a></h2><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>create table 表名称 (</span></span>
<span class="line"><span>    ... ...</span></span>
<span class="line"><span>    ...</span></span>
<span class="line"><span>    )engine = 引擎名称;</span></span></code></pre></div><hr><h2 id="查看sql当前可使用引擎" tabindex="-1">查看SQL当前可使用引擎 <a class="header-anchor" href="#查看sql当前可使用引擎" aria-label="Permalink to “查看SQL当前可使用引擎”">​</a></h2><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>show engines;</span></span></code></pre></div><hr><h2 id="存储引擎特点" tabindex="-1">存储引擎特点 <a class="header-anchor" href="#存储引擎特点" aria-label="Permalink to “存储引擎特点”">​</a></h2><h3 id="innodb-兼顾高性能和高可靠性" tabindex="-1">InnoDB：兼顾高性能和高可靠性 <a class="header-anchor" href="#innodb-兼顾高性能和高可靠性" aria-label="Permalink to “InnoDB：兼顾高性能和高可靠性”">​</a></h3><p>DML操作遵循ACID模型，支持事务 行级锁，提高并发性能 支持外键FOREIGN KEY约束，保证数据完整性和可靠性 会创建 表名.ibd 文件，存储表结构，数据，索引</p><hr><h2 id="myisam-早期的默认引擎" tabindex="-1">MyISAM：早期的默认引擎 <a class="header-anchor" href="#myisam-早期的默认引擎" aria-label="Permalink to “MyISAM：早期的默认引擎”">​</a></h2><p>不支持事务，不支持外键。 支持表锁，不支持行锁 访问速度快 会创建 .MYD .MYI .sdi .MYD 存储数据 .MYI 存储索引 .sdi 存储表结构和信息</p><hr><h2 id="memory-此引擎将数据存放在内存中-所以断电后数据会丢失-所以只能作为临时表使用" tabindex="-1">Memory：此引擎将数据存放在内存中，所以断电后数据会丢失，所以只能作为临时表使用 <a class="header-anchor" href="#memory-此引擎将数据存放在内存中-所以断电后数据会丢失-所以只能作为临时表使用" aria-label="Permalink to “Memory：此引擎将数据存放在内存中，所以断电后数据会丢失，所以只能作为临时表使用”">​</a></h2><p>访问速度快 支持hash索引 创建 .sdi 文件 存放表结构信息</p><hr><h2 id="引擎选择" tabindex="-1">引擎选择 <a class="header-anchor" href="#引擎选择" aria-label="Permalink to “引擎选择”">​</a></h2><p>对事务的完整性要求较高，在并发情况下要求数据一致的情况下选择InnoDB 对数据的插入和读取为主：MyISAM 访问速度快，存储数据量小：Memory</p><hr><h1 id="索引" tabindex="-1">索引 <a class="header-anchor" href="#索引" aria-label="Permalink to “索引”">​</a></h1><p>在数据日益增多，数据库会变得越来越臃肿，查询的成本也逐步提高，为了降低查询成本，出现了索引 索引是一种用于查询的有序的数据结构</p><p>优点： 可以高效的查询数据，降低IO成本 通过索引排序，降低CPU消耗</p><p>缺点： 索引需要空间 降低更新效率</p><hr><h2 id="索引结构" tabindex="-1">索引结构 <a class="header-anchor" href="#索引结构" aria-label="Permalink to “索引结构”">​</a></h2><table tabindex="0"><thead><tr><th>索引结构</th><th>描述</th></tr></thead><tbody><tr><td>B+Tree</td><td>最常见的索引结构，大部分引擎支持</td></tr><tr><td>Hash索引</td><td>使用哈希表实现，不支持范围查询</td></tr><tr><td>R-Tree索引（空间索引）</td><td>特殊类，通常用在地理类型的数据上，使用较少</td></tr><tr><td>Full-Text索引（全文索引）</td><td>是一种通过建立倒排索引，快速匹配文档的方式</td></tr></tbody></table><hr><h2 id="支持情况" tabindex="-1">支持情况 <a class="header-anchor" href="#支持情况" aria-label="Permalink to “支持情况”">​</a></h2><p><img src="https://banxia-log.oss-cn-beijing.aliyuncs.com/MySQL/%E5%BC%95%E6%93%8E%E6%94%AF%E6%8C%81%E7%B4%A2%E5%BC%95%E6%83%85%E5%86%B5.png" alt=""></p><hr><h2 id="索引分类" tabindex="-1">索引分类 <a class="header-anchor" href="#索引分类" aria-label="Permalink to “索引分类”">​</a></h2><p><img src="https://banxia-log.oss-cn-beijing.aliyuncs.com/MySQL/%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB.png" alt=""></p><p><strong>主键索引</strong>：如果创建主键列，就自动创建主键索引 <strong>唯一索引</strong>：避免值重复，如果字段有唯一约束，就会创建唯一索引 <strong>常规索引</strong>：特指的，快速定位数据 <strong>全文索引</strong>：阿巴阿巴</p><h3 id="存储形式分类" tabindex="-1">存储形式分类 <a class="header-anchor" href="#存储形式分类" aria-label="Permalink to “存储形式分类”">​</a></h3><p><img src="https://banxia-log.oss-cn-beijing.aliyuncs.com/MySQL/%E7%B4%A2%E5%BC%95%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%88%86%E7%B1%BB.png" alt=""></p><p>主要是通过叶子结点存储的数据区的内容分类的 聚集索引的data区存储的是整行的数据，指针区是id， 但是，查找并不会一直通过查找主键来确定一行数据，也不能将每一个字段做成一个聚集索引，会导致行数据被多次存储，浪费空间 所以就出现了二级索引，二级索引的叶子结点是id，指针可以是各行数据，通过二级索引我们可以找到对应的id，就可以再通过聚集索引来查找数据，这就是为什么聚集索引叫做聚集索引</p><p>问题出现了：如果一个表没有主键字段，不就不能生成聚集索引了吗？ <img src="https://banxia-log.oss-cn-beijing.aliyuncs.com/MySQL/%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E9%80%89%E5%8F%96%E8%A7%84%E5%88%99.png" alt=""></p><p>超级数据库提供了超级方法！！！</p><hr><h2 id="索引语法" tabindex="-1">索引语法 <a class="header-anchor" href="#索引语法" aria-label="Permalink to “索引语法”">​</a></h2><h3 id="创建" tabindex="-1">创建 <a class="header-anchor" href="#创建" aria-label="Permalink to “创建”">​</a></h3><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>create [unique | fulltext] index Index_name on Table_name (index_col_name [,...]);</span></span></code></pre></div><p><strong>unique</strong>：唯一索引，该字段必须有唯一字段标志 <strong>fulltext</strong>：全文索引 如果二者都没有，就会默认创建一个常规索引 <strong>Index_name</strong>：索引名称 <strong>Table_name</strong>：表名称 <strong>index_col_name</strong>：字段名称，可以关联多个字段，如果没关联，就被称为单列索引，关联了就被称为组合索引，多列索引</p><hr><h3 id="查看" tabindex="-1">查看 <a class="header-anchor" href="#查看" aria-label="Permalink to “查看”">​</a></h3><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>show index from Table_name;</span></span></code></pre></div><p>可以查看整张表的索引</p><hr><h3 id="删除" tabindex="-1">删除 <a class="header-anchor" href="#删除" aria-label="Permalink to “删除”">​</a></h3><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>drop index Index_name on table_name;</span></span></code></pre></div><p>删除指定表的指定索引</p><hr><h1 id="性能分析" tabindex="-1">性能分析 <a class="header-anchor" href="#性能分析" aria-label="Permalink to “性能分析”">​</a></h1><h2 id="查询sql语句使用频率" tabindex="-1">查询SQL语句使用频率 <a class="header-anchor" href="#查询sql语句使用频率" aria-label="Permalink to “查询SQL语句使用频率”">​</a></h2><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>show [global | session] status like &#39;com_______&#39;;</span></span></code></pre></div><p><strong>globle</strong>：全局 <strong>session</strong>：当前会话</p><hr><h2 id="慢查询日志" tabindex="-1">慢查询日志 <a class="header-anchor" href="#慢查询日志" aria-label="Permalink to “慢查询日志”">​</a></h2><p>对于那些超过了指定默认运行时间的指令，SQL会记录到慢查询日志中，通过查询这个日志，我们可以针对性的对其进行头花</p><h3 id="查看慢查询日志是否打开" tabindex="-1">查看慢查询日志是否打开 <a class="header-anchor" href="#查看慢查询日志是否打开" aria-label="Permalink to “查看慢查询日志是否打开”">​</a></h3><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>show variables like &#39;slow_query_log&#39;;</span></span></code></pre></div><h3 id="打开日志" tabindex="-1">打开日志 <a class="header-anchor" href="#打开日志" aria-label="Permalink to “打开日志”">​</a></h3><p>/etc/my.cnf文件下添加</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span># 慢查询日志开启</span></span>
<span class="line"><span>low_query_log=1</span></span>
<span class="line"><span># 设置超时时间</span></span>
<span class="line"><span>long_query_time=2</span></span></code></pre></div><p>日志名称：localhost-show.log</p><hr><h2 id="profile" tabindex="-1">Profile <a class="header-anchor" href="#profile" aria-label="Permalink to “Profile”">​</a></h2><p>慢查询日志只能记录超过限定时间的SQL，不能查询所有语句的耗时，Profile就可以满足</p><h3 id="查看是否支持profile操作" tabindex="-1">查看是否支持profile操作 <a class="header-anchor" href="#查看是否支持profile操作" aria-label="Permalink to “查看是否支持profile操作”">​</a></h3><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>select @@have_profiling;</span></span></code></pre></div><hr><h3 id="查看是否开启" tabindex="-1">查看是否开启 <a class="header-anchor" href="#查看是否开启" aria-label="Permalink to “查看是否开启”">​</a></h3><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>select @@profiling;</span></span></code></pre></div><hr><h3 id="开启profile" tabindex="-1">开启profile <a class="header-anchor" href="#开启profile" aria-label="Permalink to “开启profile”">​</a></h3><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>set [session | global] profiling = 1;</span></span></code></pre></div><p><strong>session</strong>：当前会话 <strong>global</strong>：全局会话</p><hr><h3 id="查看profile" tabindex="-1">查看profile <a class="header-anchor" href="#查看profile" aria-label="Permalink to “查看profile”">​</a></h3><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>show profiles;</span></span></code></pre></div><hr><h3 id="查看指定语句耗时" tabindex="-1">查看指定语句耗时 <a class="header-anchor" href="#查看指定语句耗时" aria-label="Permalink to “查看指定语句耗时”">​</a></h3><p>里面有各种阶段的耗时，可以通过这个进行更加细节的优化</p><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>show profile cpu for query query_id;</span></span></code></pre></div><hr><h2 id="explain执行计划" tabindex="-1">explain执行计划 <a class="header-anchor" href="#explain执行计划" aria-label="Permalink to “explain执行计划”">​</a></h2><p>可以查看select执行过程中的细节</p><h3 id="调用" tabindex="-1">调用 <a class="header-anchor" href="#调用" aria-label="Permalink to “调用”">​</a></h3><p>在任意的查询语句之前加上 desc | explain 就可以查看该语句的执行计划</p><h3 id="字段含义" tabindex="-1">字段含义 <a class="header-anchor" href="#字段含义" aria-label="Permalink to “字段含义”">​</a></h3><p><strong>ID</strong>：查询序号，执行查询语句的执行循序，ID相同，从上到下，ID不同，值越大越先执行 <strong>select_type</strong>：查询类型。意义不大，可以自行搜索 <strong>type</strong>：连接类型：性能由好到差依次是：null，system，Const，eq_ref，ref，range，Index，All 在优化中，我们一般想要连接类型尽量靠前 <strong>possible_key</strong>：可能用到的索引 <strong>key</strong>：实际使用的索引 <strong>key_len</strong>：索引使用的字节数目 <strong>rows</strong>：可能要查询的行数 <strong>filtered</strong>：返回行数占据查询行数的百分比 <strong>extra</strong>：额外信息</p><h1 id="索引使用原则" tabindex="-1">索引使用原则 <a class="header-anchor" href="#索引使用原则" aria-label="Permalink to “索引使用原则”">​</a></h1><h2 id="最左前缀法则" tabindex="-1">最左前缀法则 <a class="header-anchor" href="#最左前缀法则" aria-label="Permalink to “最左前缀法则”">​</a></h2><p>对于多列索引，查询时想要使用多列索引，查询的字段必须是使用前缀的，如果不使用左侧字段，则不会使用此索引 例如，一个索引构建的字段有name,gender,age三个字段， 如果只查询age字段，就不会使用这个索引，因为缺少前缀 如果查询name,gender字段，name字段会调用索引，gender不会调用索引，因为gender缺少前缀 总结下来：因为数据结构的原因，对于一个多列索引，必须先查询前面的，后面的才能被查询 注意：where中的字段的排序方式不会影响法则的使用</p><hr><h2 id="范围查询" tabindex="-1">范围查询 <a class="header-anchor" href="#范围查询" aria-label="Permalink to “范围查询”">​</a></h2><p>使用返回查询的字段，查询右侧的列索引失效。 例如，一个索引构建的字段有name,gender,age三个字段， 如果查询name,gender&gt;30,age字段，那么age将会失效 如果使用&gt;=就不会失效</p><hr><h2 id="计算问题" tabindex="-1">计算问题 <a class="header-anchor" href="#计算问题" aria-label="Permalink to “计算问题”">​</a></h2><p>如果字段被计算，则不能使用索引 例如，一个索引构建的字段有name,gender,age三个字段， 如果查询 substring(name,3,1)就不会使用name索引</p><hr><h2 id="引号问题" tabindex="-1">引号问题 <a class="header-anchor" href="#引号问题" aria-label="Permalink to “引号问题”">​</a></h2><p>如果字符串不加引号，索引将会失效</p><hr><h2 id="模糊查询问题" tabindex="-1">模糊查询问题 <a class="header-anchor" href="#模糊查询问题" aria-label="Permalink to “模糊查询问题”">​</a></h2><p>尾部模糊就不会失效，头部模糊就会失效 和前面的范围查询问题一样，因为没有明确的起点</p><hr><h2 id="or问题" tabindex="-1">or问题 <a class="header-anchor" href="#or问题" aria-label="Permalink to “or问题”">​</a></h2><p>如果查询的条件用or链接，如果前后有无索引字段，就不会使用索引 因为如果存在没有索引的字段，就要全表扫描了，既然要扫描了，再用一遍索引反而是浪费时间</p><hr><h2 id="数据分布影响" tabindex="-1">数据分布影响 <a class="header-anchor" href="#数据分布影响" aria-label="Permalink to “数据分布影响”">​</a></h2><p>如果MySQL评估全表扫描比索引效率更高，则放弃使用索引 为什么会放弃呢：MySQL优化器决定的，不是很懂</p><hr><h2 id="mysql提示" tabindex="-1">MySQL提示 <a class="header-anchor" href="#mysql提示" aria-label="Permalink to “MySQL提示”">​</a></h2><p>就是在SQL中加入提示，告诉数据库使用或者不使用某个索引，达到人为优化的目的 插入位置：where之前</p><h3 id="提示词" tabindex="-1">提示词 <a class="header-anchor" href="#提示词" aria-label="Permalink to “提示词”">​</a></h3><p><strong>建议使用</strong>：use Index (索引名) <strong>禁止使用</strong>：ignore Index (索引名) <strong>必须使用</strong>：force Index (索引名)</p><hr><h2 id="覆盖索引" tabindex="-1">覆盖索引 <a class="header-anchor" href="#覆盖索引" aria-label="Permalink to “覆盖索引”">​</a></h2><p>对于联合索引，我们在查询时，尽量只查询索引内部的字段，这样仅仅查询索引表就可以获取信息， 如果查询到了索引外部的字段，就需要实行回表查询，就多查询ID索引表，降低了性能</p><hr><h2 id="前缀索引" tabindex="-1">前缀索引 <a class="header-anchor" href="#前缀索引" aria-label="Permalink to “前缀索引”">​</a></h2><p>为什么需要前缀索引：在一些表中，字段类型为字符串的时候，如果字符串比较长，做成索引的话，查询起来就会浪费磁盘的IO资源 我们可以只对字符串的前部分建立前缀索引，提高查询效率</p><h3 id="创建-1" tabindex="-1">创建 <a class="header-anchor" href="#创建-1" aria-label="Permalink to “创建”">​</a></h3><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>create [unique | fulltext] index Index_name on Table_name (index_col_name(n) [,...]);</span></span></code></pre></div><p><strong>n</strong>：字段前缀</p><hr><h2 id="单列索引的效率比联合索引效率低" tabindex="-1">单列索引的效率比联合索引效率低 <a class="header-anchor" href="#单列索引的效率比联合索引效率低" aria-label="Permalink to “单列索引的效率比联合索引效率低”">​</a></h2><p>所以我们推荐使用联合索引</p><hr><h1 id="索引的设计原则" tabindex="-1">索引的设计原则 <a class="header-anchor" href="#索引的设计原则" aria-label="Permalink to “索引的设计原则”">​</a></h1><p>1：数据量比较大：超过100w，访问频繁的表，我们一般认为要创建索引 2：尝尝针对 查询条件 where，排序 order by，分组 group by 操作建立索引 3：选择区分度高的字段建立索引，尽量建立唯一索引，区分度越高，效率越高 4：字符串字段，如果字符串比较长，建立前缀索引 5：尽量使用联合索引，使用覆盖索引，节省空间，避免回表查询，提高效率 6：控制索引数量，避免冗余索引 7：如果不能存在NULL值，创建表的时候记得标记，更方便优化器进行优化</p><hr><h1 id="sql优化" tabindex="-1">SQL优化 <a class="header-anchor" href="#sql优化" aria-label="Permalink to “SQL优化”">​</a></h1><h2 id="插入优化" tabindex="-1">插入优化 <a class="header-anchor" href="#插入优化" aria-label="Permalink to “插入优化”">​</a></h2><h3 id="insert" tabindex="-1">insert <a class="header-anchor" href="#insert" aria-label="Permalink to “insert”">​</a></h3><h4 id="批量插入" tabindex="-1">批量插入 <a class="header-anchor" href="#批量插入" aria-label="Permalink to “批量插入”">​</a></h4><p>批量插入可以避免频繁地与数据库建立连接，用一次链接就插入大量的数据可以大大的提升效率</p><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>insert into 表名 [(字段1,字段2,......,字段n)] values (数据1,数据2,......,数据n)[，(数据1,数据2,......,数据n)，(数据1,数据2,......,数据n)];insert</span></span></code></pre></div><hr><h4 id="手动提交事务" tabindex="-1">手动提交事务 <a class="header-anchor" href="#手动提交事务" aria-label="Permalink to “手动提交事务”">​</a></h4><p>因为每执行一条插入语句，mysql就会自动的开启一个事务，语句结束就提交事务，即使我们使用批量插入，还是会造成大量的浪费，避免这种情况，我们需要手动的开启和提交事务。</p><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>start transaction ;</span></span>
<span class="line"><span>insert ... ;</span></span>
<span class="line"><span>insert ... ;</span></span>
<span class="line"><span>insert ... ;</span></span>
<span class="line"><span>commit ;</span></span></code></pre></div><p>可以节省事务方面的开销</p><hr><h4 id="主键顺序插入" tabindex="-1">主键顺序插入 <a class="header-anchor" href="#主键顺序插入" aria-label="Permalink to “主键顺序插入”">​</a></h4><p>对于有主键的表格，建议按照主键的顺序插入数据</p><hr><h3 id="load" tabindex="-1">load <a class="header-anchor" href="#load" aria-label="Permalink to “load”">​</a></h3><p>对于大量数据的插入，insert就不适用了，我们可以使用load大量的去加载本地文件的数据</p><p>使用load需要对数据库进行操作：</p><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span># 客户端连接服务端 加上参数 --local-infile</span></span>
<span class="line"><span>MySQL --local-infile -u root -p</span></span>
<span class="line"><span># 设置全局参数 local-infile开关，开启从本地文件导入数据的开关</span></span>
<span class="line"><span>set global local_infile = 1;</span></span>
<span class="line"><span># 使用load语句导入数据</span></span>
<span class="line"><span>load data local infile &quot;文件路径/文件名&quot; into table &#39;表名&#39; fields terminated by &#39;字段分隔符&#39;</span></span>
<span class="line"><span>	lines terminated by &#39;行分隔符&#39;;</span></span></code></pre></div><hr><h2 id="主键优化" tabindex="-1">主键优化 <a class="header-anchor" href="#主键优化" aria-label="Permalink to “主键优化”">​</a></h2><h3 id="数据组织方式" tabindex="-1">数据组织方式 <a class="header-anchor" href="#数据组织方式" aria-label="Permalink to “数据组织方式”">​</a></h3><p>表数据都是根据主键顺序存放的，这种存储结构叫做索引组织表</p><p>因为聚集索引的默认索引是主键索引，索引下挂的数据是行数据</p><hr><h3 id="页分裂-页合并" tabindex="-1">页分裂&amp;页合并 <a class="header-anchor" href="#页分裂-页合并" aria-label="Permalink to “页分裂&amp;页合并”">​</a></h3><p>数据按照主键存储，如果插入或者删除不是顺序的，为了维护数据表，就会调用这两个操作，会造成性能损耗。</p><hr><h3 id="设计原则" tabindex="-1">设计原则： <a class="header-anchor" href="#设计原则" aria-label="Permalink to “设计原则：”">​</a></h3><p>1：尽量降低主键的长度 2：主键尽量顺序插入，避免出现页分裂的情况 3：尽量不使用UUID作为主键，如身份证号 4：业务尽量避免对主键的修改，因为维护索引会造成大量的性能开支</p><hr><h2 id="order-by-优化" tabindex="-1">order by 优化 <a class="header-anchor" href="#order-by-优化" aria-label="Permalink to “order by 优化”">​</a></h2><p>首先，排序分为两种排序操作：using filesort 和 using Index</p><p><strong>using filesort</strong>：通过索引或者全表扫描，获取到数据之后，在缓冲区sort Buffer 中完成排序操作。不是通过索引直接读取到排好序的数据都叫做filesort排序</p><p><strong>using Index</strong>：很显然，直接诶读取到排好序的数据的操作叫做Index排序，操作效率高</p><h3 id="设计原则-1" tabindex="-1">设计原则： <a class="header-anchor" href="#设计原则-1" aria-label="Permalink to “设计原则：”">​</a></h3><p>1：根据排序的字段建立适合的索引 2：尽量使用覆盖索引 3：注意创建的规则细节（asc/ desc） 4：不可避免出现filesort时，可以调节缓冲区大小，默认为256k</p><hr><h2 id="group-by-优化" tabindex="-1">group by 优化 <a class="header-anchor" href="#group-by-优化" aria-label="Permalink to “group by 优化”">​</a></h2><p>好像也没什么注意的，就是要建立联合索引，满足最左前缀法则之类的</p><hr><h2 id="limit-分页查询-优化" tabindex="-1">limit 分页查询 优化 <a class="header-anchor" href="#limit-分页查询-优化" aria-label="Permalink to “limit 分页查询 优化”">​</a></h2><p>因为数据结构是B+树的原因，分页查询如果页数比较靠后，就会从开头进行遍历操作，相当浪费时间。</p><p>可以创建覆盖索引，通过联合查询或者子查询来解决问题</p><hr><h2 id="count优化" tabindex="-1">count优化 <a class="header-anchor" href="#count优化" aria-label="Permalink to “count优化”">​</a></h2><p>这个对于不同的引擎，count的效率也会不同 <strong>MyISAM</strong> 引擎把一个表的总行数存在了磁盘上，count( * )会直接返回 <strong>InnoDb</strong> 引擎执行count( * )会把表的所有数据读取出来，然后计数</p><p>count原理：count会对结果集进行一步步地判断，如果结果不是null，累计值就加一，最后返回累计值</p><p>count( * )：数据库做了优化，不会取出一行行的数据，所以尽量使用 count( * )</p><hr><h2 id="update优化" tabindex="-1">update优化 <a class="header-anchor" href="#update优化" aria-label="Permalink to “update优化”">​</a></h2><p>update在更新数据的时候，为了数据的安全，会对数据进行加锁操作。 数据的加锁操作是根据索引添加的行锁，如果索引失效，就会升级为表锁 如果更新数据的条件可以调用索引查找到，就只对当前行进行加行锁，如果条件不能够用索引查询，就只能对整张表进行加锁，此时，数据库的并发性能就会大大降低。 因此，数据库在更新数据时，筛选条件应该尽量依靠索引，避免行锁升级为表锁。</p><hr><h1 id="视图" tabindex="-1">视图 <a class="header-anchor" href="#视图" aria-label="Permalink to “视图”">​</a></h1><p>视图作为表存在于数据库，但是并不存储数据，而是存储查询逻辑，每次调用视图的时候，就执行一遍这个封装好的逻辑。</p><h2 id="创建视图" tabindex="-1">创建视图 <a class="header-anchor" href="#创建视图" aria-label="Permalink to “创建视图”">​</a></h2><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>create [or replace] view view_name as select...;</span></span></code></pre></div><p><strong>or replace</strong>：如果这个视图存在就更新</p><hr><h2 id="查询创建语句" tabindex="-1">查询创建语句 <a class="header-anchor" href="#查询创建语句" aria-label="Permalink to “查询创建语句”">​</a></h2><div class="language-MySQL"><button title="Copy Code" class="copy"></button><span class="lang">MySQL</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>show create view view_name;</span></span></code></pre></div><hr><h2 id="查询视图" tabindex="-1">查询视图 <a class="header-anchor" href="#查询视图" aria-label="Permalink to “查询视图”">​</a></h2><p>视图在数据库中是作为表出现的，因此查询操作和查询表的语句相同</p><hr><h2 id="修改视图" tabindex="-1">修改视图 <a class="header-anchor" href="#修改视图" aria-label="Permalink to “修改视图”">​</a></h2><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span># 方法一：</span></span>
<span class="line"><span>create or replace view view_name as select ...;</span></span>
<span class="line"><span># 方法二</span></span>
<span class="line"><span>alter view view_name as select...;</span></span></code></pre></div><hr><h2 id="删除视图" tabindex="-1">删除视图 <a class="header-anchor" href="#删除视图" aria-label="Permalink to “删除视图”">​</a></h2><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>drop view [if exists] view_name [,vire_name];</span></span></code></pre></div><hr><h2 id="检查选项" tabindex="-1">检查选项 <a class="header-anchor" href="#检查选项" aria-label="Permalink to “检查选项”">​</a></h2><p>视图是以表的形式呈现的，，那自然也可以进行增删改查，当然，视图存储的是逻辑，如果加入了数据，会加入到基表，而不是视图，如果添加了视图查询不到的条目，就会出现问题。 为了解决问题，就诞生了检查选项用来检查操作是否合法</p><h3 id="添加检查选项" tabindex="-1">添加检查选项 <a class="header-anchor" href="#添加检查选项" aria-label="Permalink to “添加检查选项”">​</a></h3><p>在创建视图语句之后加上 with [cascade | local] check option 视图就会检查更新，阻止不符合视图创建规范的SQL执行。 另外，MySQL允许根据视图创建视图，因此，检查范围成了问题。为了确定检查的范围，mysql加入了两个范围限定 <strong>cascade</strong>：级联，如果在子视图加入了这个条件，通过子视图更新基表的操作会检查父视图的规范。 <strong>local</strong>：局部检查，如果父视图没有定义条件，就不检查</p><hr><h2 id="视图的更新" tabindex="-1">视图的更新 <a class="header-anchor" href="#视图的更新" aria-label="Permalink to “视图的更新”">​</a></h2><p>视图可以更新基表的条件：视图的数据必须是和基表是一对一对应的关系，如果数据经过了函数加工，就不能通过视图更新基表</p><p>例如：聚合函数，筛选函数，分组，等函数</p><hr><h2 id="视图作用" tabindex="-1">视图作用 <a class="header-anchor" href="#视图作用" aria-label="Permalink to “视图作用”">​</a></h2><p>这个玩意有什么用呢？：</p><p><strong>简单</strong>：简化操作，对于复杂度语句，使用频次比较高的语句都适合转化为视图去呈现。 <strong>安全</strong>：可以只对用户授予视图权限，使得用户只能看到视图所展示的数据，可以保护数据 <strong>数据独立</strong>：屏蔽基表的变化对视图的影响（可以取别名，只查看某些字段）</p><hr><h1 id="存储过程" tabindex="-1">存储过程 <a class="header-anchor" href="#存储过程" aria-label="Permalink to “存储过程”">​</a></h1><p>---类似于函数的思想</p><p>在操作数据库的时候，每条语句都会建立一次链接，这造成了很大的开销，我们可以把一些SQL存储到数据库本身，外部调用仅仅掉用这个SQL集合就可以实现一系列操作，我们把这个集合叫做存储过程。</p><p><strong>特点</strong>：</p><p>​ 1：封装，复用 ​ 2：可以接受参数，返回结果 ​ 3：减少网络开支</p><h2 id="创建-2" tabindex="-1">创建 <a class="header-anchor" href="#创建-2" aria-label="Permalink to “创建”">​</a></h2><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>create procedure procedure_name ([参数])</span></span>
<span class="line"><span>begin</span></span>
<span class="line"><span>    存储体语句;</span></span>
<span class="line"><span>end;</span></span></code></pre></div><hr><h2 id="使用" tabindex="-1">使用 <a class="header-anchor" href="#使用" aria-label="Permalink to “使用”">​</a></h2><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>call procedure_name([参数]);</span></span></code></pre></div><hr><h2 id="查询" tabindex="-1">查询 <a class="header-anchor" href="#查询" aria-label="Permalink to “查询”">​</a></h2><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span># 根据主机名查看</span></span>
<span class="line"><span>select * from information_schema.ROUTINES</span></span>
<span class="line"><span>    where ROUTINE_SCHEMA = &#39;数据库名称&#39;;</span></span>
<span class="line"><span># 根据存储过程名查看</span></span>
<span class="line"><span>show create procedure p1;</span></span></code></pre></div><hr><h2 id="删除-1" tabindex="-1">删除 <a class="header-anchor" href="#删除-1" aria-label="Permalink to “删除”">​</a></h2><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>drop procedure if exists procedure_name;</span></span></code></pre></div><hr><h2 id="变量" tabindex="-1">变量 <a class="header-anchor" href="#变量" aria-label="Permalink to “变量”">​</a></h2><h3 id="系统变量" tabindex="-1">系统变量 <a class="header-anchor" href="#系统变量" aria-label="Permalink to “系统变量”">​</a></h3><p>由mysql数据库创建，不是由用户定义的，属于服务器层面，分为全局变量【global】和回话变量【session】用 @@变量名 表示；</p><h4 id="查看系统变量" tabindex="-1">查看系统变量 <a class="header-anchor" href="#查看系统变量" aria-label="Permalink to “查看系统变量”">​</a></h4><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>show [global | session(默认)] variables [like ...];</span></span>
<span class="line"><span># 也可以指定变量查找</span></span>
<span class="line"><span>select @@ [global | session] 系统变量名;</span></span></code></pre></div><hr><h4 id="设置系统变量" tabindex="-1">设置系统变量 <a class="header-anchor" href="#设置系统变量" aria-label="Permalink to “设置系统变量”">​</a></h4><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>set [@@] [global | session] 系统变量名 = 值;</span></span></code></pre></div><hr><h3 id="用户变量" tabindex="-1">用户变量 <a class="header-anchor" href="#用户变量" aria-label="Permalink to “用户变量”">​</a></h3><p>用户变量不需要提前声明，在使用的时候直接用 @变量名 就可以使用，作用域为当前会话</p><h4 id="赋值" tabindex="-1">赋值 <a class="header-anchor" href="#赋值" aria-label="Permalink to “赋值”">​</a></h4><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span># 方法一</span></span>
<span class="line"><span>set @var_name [:]= 值 [,@var_name = 值];</span></span>
<span class="line"><span># 方法二</span></span>
<span class="line"><span>select @var_name [:]= 值 [,@var_name = 值];</span></span>
<span class="line"><span># 方法三</span></span>
<span class="line"><span>select 字段名 into @Var_name from table_name;</span></span></code></pre></div><hr><h4 id="使用-1" tabindex="-1">使用 <a class="header-anchor" href="#使用-1" aria-label="Permalink to “使用”">​</a></h4><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>select @var_name [,@var_name];</span></span></code></pre></div><p>如果使用了一个没有初始化的变量，就会返回一个负值</p><hr><h3 id="局部变量" tabindex="-1">局部变量 <a class="header-anchor" href="#局部变量" aria-label="Permalink to “局部变量”">​</a></h3><p>局部变量需要声明才能使用，生命周期在一段 begin和end中。</p><h4 id="声明" tabindex="-1">声明： <a class="header-anchor" href="#声明" aria-label="Permalink to “声明：”">​</a></h4><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>declare var_name 变量类型 [default];</span></span></code></pre></div><p><strong>default</strong>：指定变量默认值；</p><hr><h4 id="赋值-1" tabindex="-1">赋值 <a class="header-anchor" href="#赋值-1" aria-label="Permalink to “赋值”">​</a></h4><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span># 方法一</span></span>
<span class="line"><span>set @var_name [:]= 值 [,@var_name = 值];</span></span>
<span class="line"><span># 方法二</span></span>
<span class="line"><span>select @var_name [:]= 值 [,@var_name = 值];</span></span>
<span class="line"><span># 方法三</span></span>
<span class="line"><span>select 字段名 into @Var_name from table_name;</span></span></code></pre></div><hr><h2 id="if" tabindex="-1">if <a class="header-anchor" href="#if" aria-label="Permalink to “if”">​</a></h2><h3 id="结构" tabindex="-1">结构 <a class="header-anchor" href="#结构" aria-label="Permalink to “结构”">​</a></h3><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>if 条件 then</span></span>
<span class="line"><span>	结果</span></span>
<span class="line"><span>elseif 条件 then</span></span>
<span class="line"><span>	结果</span></span>
<span class="line"><span>else</span></span>
<span class="line"><span>	结果</span></span>
<span class="line"><span>end if;</span></span></code></pre></div><h2 id="参数" tabindex="-1">参数 <a class="header-anchor" href="#参数" aria-label="Permalink to “参数”">​</a></h2><p><img src="https://banxia-log.oss-cn-beijing.aliyuncs.com/MySQL/%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B.png" alt=""></p><h3 id="示例" tabindex="-1">示例 <a class="header-anchor" href="#示例" aria-label="Permalink to “示例”">​</a></h3><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>create procedure p2(in s int,out str varchar(10),inout teacher_name varchar(10))</span></span>
<span class="line"><span>begin</span></span>
<span class="line"><span>    set teacher_name := concat(substring(teacher_name,1,1),&#39;老师&#39;);</span></span>
<span class="line"><span>    if s &gt;= 60 then</span></span>
<span class="line"><span>        set str := &#39;及格&#39;;</span></span>
<span class="line"><span>    else</span></span>
<span class="line"><span>        set str := &#39;及格&#39;;</span></span>
<span class="line"><span>    end if;</span></span>
<span class="line"><span>end;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>set @teacher_name = &#39;王天正&#39;;</span></span>
<span class="line"><span>call p2(60,@str,@teacher_name);</span></span>
<span class="line"><span>select @str,@teacher_name;</span></span></code></pre></div><hr><h2 id="case" tabindex="-1">case <a class="header-anchor" href="#case" aria-label="Permalink to “case”">​</a></h2><h3 id="结构-1" tabindex="-1">结构 <a class="header-anchor" href="#结构-1" aria-label="Permalink to “结构”">​</a></h3><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span># 结构一：通过比较值是否相等，判断执行哪一条语句</span></span>
<span class="line"><span>case 值</span></span>
<span class="line"><span>	when 值 SQL</span></span>
<span class="line"><span>	[when 值 SQL]</span></span>
<span class="line"><span>	[else SQL]</span></span>
<span class="line"><span>end case;</span></span>
<span class="line"><span># 结构一：通过判断每条分支表达式的值，来决定执行哪一条语句</span></span>
<span class="line"><span>case</span></span>
<span class="line"><span>	when 表达式 SQL</span></span>
<span class="line"><span>	[when 表达式 SQL]</span></span>
<span class="line"><span>	[else SQL]</span></span>
<span class="line"><span>end case;</span></span></code></pre></div><hr><h2 id="循环" tabindex="-1">循环 <a class="header-anchor" href="#循环" aria-label="Permalink to “循环”">​</a></h2><h3 id="while" tabindex="-1">while <a class="header-anchor" href="#while" aria-label="Permalink to “while”">​</a></h3><p>while别看长得像do-while 其实就是while</p><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>while 条件 do </span></span>
<span class="line"><span>	SQL...</span></span>
<span class="line"><span>end while;</span></span></code></pre></div><hr><h3 id="repeat" tabindex="-1">repeat <a class="header-anchor" href="#repeat" aria-label="Permalink to “repeat”">​</a></h3><p>其实是do-while....不对！repeat是满足条件就退出，而不是满足条件就继续执行！！！</p><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>repeat</span></span>
<span class="line"><span>	SQL...</span></span>
<span class="line"><span>	until 条件</span></span>
<span class="line"><span>end repeat;</span></span></code></pre></div><hr><h3 id="loop-leave-iterate" tabindex="-1">loop + leave + iterate <a class="header-anchor" href="#loop-leave-iterate" aria-label="Permalink to “loop + leave + iterate”">​</a></h3><p><strong>loop</strong>：可以理解成简单的无限循环 <strong>leave</strong>：break <strong>iterate</strong>：continue</p><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>[标记名:]loop</span></span>
<span class="line"><span>	SQL...</span></span>
<span class="line"><span>end loop [标记名];</span></span></code></pre></div><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span># 离开当前标记</span></span>
<span class="line"><span>leave 标记名</span></span>
<span class="line"><span># 执行下一次标记</span></span>
<span class="line"><span>iterate 标记名</span></span></code></pre></div><hr><h2 id="游标-cursor" tabindex="-1">游标 cursor <a class="header-anchor" href="#游标-cursor" aria-label="Permalink to “游标 cursor”">​</a></h2><p>从目前看来，存储过程所返回的变量只有SQL基础的数据类型所创建的变量，但是很多时候，我们拿到的数据并不是单个的数据，通常作为一个表出现，这就出现了多对一的矛盾，为了解决这个矛盾，出现了游标</p><h3 id="声明-1" tabindex="-1">声明 <a class="header-anchor" href="#声明-1" aria-label="Permalink to “声明”">​</a></h3><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>declare 游标名称 cursor for 查询语句;</span></span></code></pre></div><p>注意，声明游标语句必须存在在变量之后</p><h3 id="开启" tabindex="-1">开启 <a class="header-anchor" href="#开启" aria-label="Permalink to “开启”">​</a></h3><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>open 游标名称</span></span></code></pre></div><h3 id="获取" tabindex="-1">获取 <a class="header-anchor" href="#获取" aria-label="Permalink to “获取”">​</a></h3><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>fetch 游标名称 into 变量 [,变量];</span></span></code></pre></div><h3 id="关闭" tabindex="-1">关闭 <a class="header-anchor" href="#关闭" aria-label="Permalink to “关闭”">​</a></h3><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>close 游标名称</span></span></code></pre></div><hr><h2 id="条件处理程序-handler" tabindex="-1">条件处理程序 handler <a class="header-anchor" href="#条件处理程序-handler" aria-label="Permalink to “条件处理程序 handler”">​</a></h2><p>在读取游标数据时，一般情况下会用到无限循环去读取，当游标为空的时候，我们再去读取就会报错，有没有不报错解决办法呢， 答案是没有，但是我们可以对错误进行处理，不让错误出现</p><p>就诞生了条件处理程序，感觉和java和py的错误处理差不错</p><h3 id="创建-3" tabindex="-1">创建 <a class="header-anchor" href="#创建-3" aria-label="Permalink to “创建”">​</a></h3><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>declare handler_action handler for condition_value [,condition——value] statement;</span></span></code></pre></div><p><strong>handler_action</strong>：发现错误后执行的操作 <strong>exit</strong>：直接退出 <strong>continue</strong>：继续执行(?)</p><p><strong>handler_action</strong>：捕捉错误 sqlstate + 状态码 sqlwarning 以01开头的状态码 not found 以02开头的状态码 sqlexception 上面二者的补集</p><p>对于上述的错误码，在SQL的官方文档有记载，不过让他先出错再修理可能更有效率（？</p><p><strong>statement</strong>：执行的SQL</p><hr><h1 id="存储函数" tabindex="-1">存储函数 <a class="header-anchor" href="#存储函数" aria-label="Permalink to “存储函数”">​</a></h1><p>存储函数是存储过程的特殊表现形式， 存储函数被要求是有返回值的存储过程，并且参数全部是 in 类型</p><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>create function 存储函数名称(参数列表)</span></span>
<span class="line"><span>returns 返回值类型 [characteristic]</span></span>
<span class="line"><span>begin</span></span>
<span class="line"><span>	SQL...</span></span>
<span class="line"><span>    return 返回值;</span></span>
<span class="line"><span>end;</span></span></code></pre></div><p><strong>characteristic</strong>： <strong>deterministic</strong>：相同的数据会产生相同的结果 <strong>no sql</strong>：不包含SQL语句 <strong>reads sql data</strong>：包含读取数据的语句，但不包含写入数据的语句</p><hr><h1 id="触发器" tabindex="-1">触发器 <a class="header-anchor" href="#触发器" aria-label="Permalink to “触发器”">​</a></h1><p>触发器是和表有关的数据库对象，和名字一样，触发器会在<strong>某些条件下</strong>被触发，执行预先写好的SQL指令集。 <strong>某些条件下</strong>：指的是一些特殊语句，比如插入，更新，删除等，可以在执行之前触发，也可以在执行之后触发 通过这些特性，我们可以做到对数据库中的数据变化进行记录，可以写写日志什么的， mysql的触发器还只支持<strong>行级触发</strong>，不支持<strong>语句触发</strong><strong>行级触发</strong>：指的是当表中的一行数据被操作时，触发器就会触发 <strong>语句触发</strong>：指的是通过语句触发的触发器</p><h2 id="触发器记录的数据" tabindex="-1">触发器记录的数据 <a class="header-anchor" href="#触发器记录的数据" aria-label="Permalink to “触发器记录的数据”">​</a></h2><p><img src="https://banxia-log.oss-cn-beijing.aliyuncs.com/MySQL/%E8%A7%A6%E5%8F%91%E5%99%A8%E8%AE%B0%E5%BD%95%E7%9A%84%E6%95%B0%E6%8D%AE.png" alt=""></p><p><strong>注意</strong>，触发器记录的数据是一行的数据，所以可以用 old.字段 / new.字段的形式调用本次触发器监听的结果</p><h2 id="创建-4" tabindex="-1">创建 <a class="header-anchor" href="#创建-4" aria-label="Permalink to “创建”">​</a></h2><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span></span></span>
<span class="line"><span>create trigger trigger_name</span></span>
<span class="line"><span>    after | before -- 前触发还是后触发</span></span>
<span class="line"><span>    insert | update | delete -- 触发器生效的SQL</span></span>
<span class="line"><span>    on table_name -- 触发器生效的表名 </span></span>
<span class="line"><span>    for each row -- 啊哈哈，因为MySQL只支持这一种触发器，所以这里只有一种写法了</span></span>
<span class="line"><span>    begin </span></span>
<span class="line"><span>        SQL...</span></span>
<span class="line"><span>    end;</span></span></code></pre></div><hr><h2 id="查看-1" tabindex="-1">查看 <a class="header-anchor" href="#查看-1" aria-label="Permalink to “查看”">​</a></h2><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>show triggers;</span></span></code></pre></div><hr><h2 id="删除-2" tabindex="-1">删除 <a class="header-anchor" href="#删除-2" aria-label="Permalink to “删除”">​</a></h2><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>drop trigger [schema_name.]trigger_name;</span></span></code></pre></div><p><strong>schema_name</strong>：指定数据库，如果没有指定，就默认当下的数据库</p><hr><h1 id="锁" tabindex="-1">锁 <a class="header-anchor" href="#锁" aria-label="Permalink to “锁”">​</a></h1><p>保护数据在高并发情况下可靠的对象</p><p>按照粒度分： <strong>全局锁</strong>：锁定所有表 <strong>表级锁</strong>：锁定整张表 <strong>行级锁</strong>：锁定对应的行</p><h2 id="全局锁" tabindex="-1">全局锁 <a class="header-anchor" href="#全局锁" aria-label="Permalink to “全局锁”">​</a></h2><p>对整个数据库加锁，整个数据库处于制只读状态，DML和DDL语句在执行中，都将处于阻塞状态，只有DQL可以执行。</p><p>典型的操作是做全库的逻辑备份，对所有的表进行锁定，获取一致性的视图，保证数据的可靠性 下面对备份情况做一个示例</p><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span># 加锁</span></span>
<span class="line"><span>flush tables with read lock ; -- 全局锁加锁</span></span></code></pre></div><div class="language-cmd"><button title="Copy Code" class="copy"></button><span class="lang">cmd</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"># 备份</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mysqldump </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">u 用户名 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">p 密码 数据库名称 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">数据库名称.sql</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"># 该指令会将数据库备份到数据库.sql中</span></span></code></pre></div><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span># 解锁</span></span>
<span class="line"><span>unlock tables ;</span></span></code></pre></div><p>这玩意不适用于中文名（？</p><h3 id="缺点" tabindex="-1">缺点 <a class="header-anchor" href="#缺点" aria-label="Permalink to “缺点”">​</a></h3><p>缺点很明显了 如果在主库备份，业务基本暂时GG 如果在从库备份，从库不能及时同步主库，容易造成主从不一致</p><h3 id="解决" tabindex="-1">解决 <a class="header-anchor" href="#解决" aria-label="Permalink to “解决”">​</a></h3><p>在 InnoDB 引擎中，我们可以在备份时加入参数 --single-transaction 来实现不加锁完成备份</p><div class="language-cmd"><button title="Copy Code" class="copy"></button><span class="lang">cmd</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mysqldump </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">single</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">transaction </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">u 用户名 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">p 密码 数据库名称 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">数据库名称.sql</span></span></code></pre></div><hr><h2 id="表级锁" tabindex="-1">表级锁 <a class="header-anchor" href="#表级锁" aria-label="Permalink to “表级锁”">​</a></h2><p>对整张表加锁，整张表处于制只读状态，DML和DDL语句在执行中，都将处于阻塞状态，只有DQL可以执行。 粒度大，发生冲突概率高，并发度低，应用在MyISAM，InnoDB，BDB存储引擎</p><p>主要分为：<strong>表锁</strong>，<strong>元数据锁 （Meta data lock）</strong>，<strong>意向锁</strong>。</p><hr><h3 id="表锁" tabindex="-1">表锁 <a class="header-anchor" href="#表锁" aria-label="Permalink to “表锁”">​</a></h3><p>分为：<strong>表共享读锁</strong>，<strong>表独占写锁</strong></p><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span># 加锁</span></span>
<span class="line"><span>lock tables table_name read/writer; </span></span>
<span class="line"><span># 解锁</span></span>
<span class="line"><span>unlock tables; \\ 关闭客户端</span></span></code></pre></div><p><strong>表共享读锁</strong>： 自己可以读，自己不可以写。别人可以读，别人不可以写 <strong>表独占写锁</strong>： 自己可以读，自己可以写，别人不可以读，别人不可以写 （太屌了</p><hr><h3 id="元数据锁-meta-data-lock" tabindex="-1">元数据锁 （Meta data lock） <a class="header-anchor" href="#元数据锁-meta-data-lock" aria-label="Permalink to “元数据锁 （Meta data lock）”">​</a></h3><p>元数据是什么呢？元数据可以简单理解为就是表结构，如果这张表有尚未提交的事务，那么就不能对表结构，也就是元数据进行修改。 MDL由系统自动控制，无须显式调用，在访问的时候就会自动加上，用于维护数据一致性。为了规避DML和DDL的冲突</p><p>MySQL在5.5引进了MDL，在执行增删改查的时候，加入MDL读锁（共享锁）在修改元数据（表结构）时，加入MDL写锁（排他锁）</p><p>加锁类型：</p><p><img src="https://banxia-log.oss-cn-beijing.aliyuncs.com/MySQL/MDL%E5%8A%A0%E9%94%81%E7%B1%BB%E5%9E%8B.png" alt=""></p><p>DDL，DQL，DCL在执行时系统都会对其进行加锁，但是DDL修改了元数据，导致其锁是独享的，也就是说，DDL在执行时，DQL和DCL都不能执行。DQL和DCL在执行时，DDL不能执行。，因为增删改查的过程中禁止元数据被修改。</p><hr><h3 id="意向锁" tabindex="-1">意向锁 <a class="header-anchor" href="#意向锁" aria-label="Permalink to “意向锁”">​</a></h3><p>在一个行级锁被加载之后，表级锁就不能添加了，表级锁在添加时需要扫描整张表，如果全部的行都没被加锁，表级锁就可以加锁。反之不能加锁。但是这样效率太低了，所以我们发明了意向锁，在任意一个行级锁被加载的时候，意向锁也被加载了，这样，表级锁在被加载之前就只用扫描意向锁就可以判断整张表有没有行锁被加载，大大的提高了效率。</p><p>意向共享锁（IS）：和表兼容锁兼容，和表排它锁互斥 意向排他锁（IX）：和表锁互斥，和意向锁兼容</p><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span># 查看意向锁加锁情况</span></span>
<span class="line"><span>select object_schema,object_name,index_name,lock_data,lock_mode,lock_data</span></span>
<span class="line"><span>    from performance_schema.data_locks;</span></span></code></pre></div><hr><h2 id="行级锁" tabindex="-1">行级锁 <a class="header-anchor" href="#行级锁" aria-label="Permalink to “行级锁”">​</a></h2><p>对整行加锁，整行处于制只读状态，DML和DDL语句在执行中，都将处于阻塞状态，只有DQL可以执行。 锁粒度最小，发生锁冲突概率低。并发度高，应用在InnoDB中 InnoDB基于索引组织的，行级锁是通过对索引项的加锁实现的</p><p>行级锁分为三类：<strong>行锁</strong>，<strong>间隙锁</strong>，<strong>临间锁</strong></p><hr><h3 id="行锁" tabindex="-1">行锁 <a class="header-anchor" href="#行锁" aria-label="Permalink to “行锁”">​</a></h3><p>防止事务对其进行delete和update操作，在RC，RR都支持</p><p>分为两种： <strong>共享锁</strong>（S）：允许其他事务获取共享锁，不允许其他事务获取本行的排它锁； <strong>排它锁</strong>（X）：阻止其他事务获取S和X；</p><p>行锁加锁类型：</p><p><img src="https://banxia-log.oss-cn-beijing.aliyuncs.com/MySQL/%E8%A1%8C%E9%94%81%E5%8A%A0%E9%94%81%E7%B1%BB%E5%9E%8B.png" alt=""></p><p>那么就诞生了一个问题，如果是通过索引精确的对一行数据进行操作，那么可以加行锁，因为其他行的数据一定不会用到，但是如果不能通过索引精确的锁定被操作行，这时候，行锁就会升级为行锁，降低性能</p><hr><h3 id="间隙锁-临间锁" tabindex="-1">间隙锁/临间锁 <a class="header-anchor" href="#间隙锁-临间锁" aria-label="Permalink to “间隙锁/临间锁”">​</a></h3><p>因为二者功能有相同的地方，放在一起写</p><p><strong>间隙锁</strong>：锁住B+树下链表的数据间隙，防止Insert对其进行操作，产生幻读，在RR支持 <strong>临间锁</strong>：锁住数据和他前面的间隙Gap，在RR级别支持</p><p>1：通过唯一索引进行等值查询，给不存在的记录加锁，就会优化为间隙锁 假如ID行从4直接跳到了10，那么对7进行操作，会直接锁住5-9的空间，此时，对6的加锁操作将会被阻塞，间隙锁会对整个间隙进 行加锁。 2：通过普通索引进行的等值查询，向右遍历，直到不满足条件时，对这段间隙加间隙锁 因为普通索引并不是唯一的，在加锁查询时，可能会有相同的索引被添加，如果这个时候被添加了，其他的事务再查询只能查询到刚 刚被添加的索引，会产生错误，因此系统会向前加锁间隙，向后寻找第一个不符合查找条件的索引之前的间隙进行加锁，防止相同的 索引插入 3：唯一索引上面的范围查询也会被加上临间锁 和上面的情况一样，符合条件的是一个范围，如果这个范围内部有新的索引被插入，就会引起数据的不可靠。 假如ID从4开始，我们查询ID大于4的时候，就会加一个从四开始到正无穷的临间锁，因为这个范围都被查询了，这个范围内部也不 允许有索引插入</p><hr><h1 id="innodb" tabindex="-1">InnoDB <a class="header-anchor" href="#innodb" aria-label="Permalink to “InnoDB”">​</a></h1><h2 id="逻辑存储结构" tabindex="-1">逻辑存储结构 <a class="header-anchor" href="#逻辑存储结构" aria-label="Permalink to “逻辑存储结构”">​</a></h2><p><img src="https://banxia-log.oss-cn-beijing.aliyuncs.com/MySQL/InnoDB%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt=""></p><hr><h2 id="架构" tabindex="-1">架构 <a class="header-anchor" href="#架构" aria-label="Permalink to “架构”">​</a></h2><p>作为MySQL5.5之后的默认引擎，自然有过人之处，擅长事务处理，具有崩溃恢复特性。</p><p>架构图：左侧是内存架构，右侧是磁盘架构</p><p><img src="https://banxia-log.oss-cn-beijing.aliyuncs.com/MySQL/InnoDB%E6%9E%B6%E6%9E%84.png" alt=""></p><h3 id="内存架构" tabindex="-1">内存架构 <a class="header-anchor" href="#内存架构" aria-label="Permalink to “内存架构”">​</a></h3><p><strong>Buffer_pool</strong>：缓冲池</p><p>​ 作为主内存的区域，里面缓存的是经常操作的数据，在执行操作时，先操作缓冲区的数据（如果没有，就去磁盘），然后再以一定的 频率刷新到磁盘，减少磁盘IO开销，加快处理速度</p><p>​ 底层以page页为单位，采用链表数据结构管理page，根据状态，page分为三种类型 ​ 1：free page 空闲page：未被使用。 ​ 2：clean page 被使用的page：数据没有被修改过 ​ 3：dirty page 脏page：被使用过的page，数据被修改过，因为缓冲区的滞后性，导致了磁盘和缓冲区数据的不一致</p><p><strong>Change Buffer</strong>：更改缓冲区</p><p>​ 主要针对非唯一的一二级索引，在执行DML时，如果数据不存在于 Buffer_pool 中，不会直接的操作磁盘，而是将变更的数据存放在 Change_Buffer中，在未来数据被读取时，再将数据合并恢复到Buffer_pool中。再将合并后的数据刷新到磁盘中。</p><p>​ <strong>意义</strong>：和聚集索引不同，二级索引通常不是唯一的，针对二级索引的修改通常是随机的，会影响到不相邻的二级索引页，如果每一次 都操作磁盘，就会造成大量的IO浪费，所以，我们在Change Buffer中进行合并操作，一齐刷新到磁盘中、</p><p><strong>Adaptive Hash Index</strong>：自适应哈希索引</p><p>​ 由于InnoDB引擎不支持哈希索引，但是哈希索引效率远远高于B+树索引，所以在查询的过程中，InnoDB引擎就会监控对各个表的索 引查询，如果建立哈希索引可以提升速度，就建立哈希索引，称之为自适应哈希索引！！！</p><p>​ 无需人工干预，由系统生成。</p><p>​ 参数：adaptive_hash_index 哈希开关</p><p><strong>Log Buffer</strong>：日志缓冲区</p><p>​ 用来保存要写入到磁盘中的日志。（redo log , undo log）默认大小为16KB，会定期刷新到磁盘。如果需要进行大量的事务。增加缓 冲区大小是一个减少IO开销不错的方法。</p><p>​ 参数：Innodb_log_buffer_size：缓冲区大小 ​ innodb_flush_log_at_trx_commit 刷新时机 ​ 0：每秒刷新一次 ​ 1：每次事务提交刷新一次 ​ 2：上两者</p><hr><h3 id="磁盘结构" tabindex="-1">磁盘结构 <a class="header-anchor" href="#磁盘结构" aria-label="Permalink to “磁盘结构”">​</a></h3><p><strong>System Tablespace</strong>：系统表空间</p><p>​ 对于8.0之后的系统表空间，存放的是Change Buffer的数据，默认存储用户在系统表空间创建的表的数据和索引。如果每张表的独立 表空间关闭，所有表的数据和索引都在系统表空间。</p><p>​ 参数：Innodb_data_dile_path</p><p><strong>File-Per-Table Tablespaces</strong>：独立表空间</p><p>​ 每个表的独立表空间，默认开启，开启之后，表的存储就不存储到系统表空间了</p><p>​ 参数：Innodb_file_per_table</p><p><strong>General Tablespaces</strong>：通用表空间</p><p>​ 需要手动创建，在创建表的时候，可以使用这个空间存储表</p><p>​ 创建：</p><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>create tablespace tablespace_name</span></span>
<span class="line"><span>    add datafile &#39;file_name&#39;</span></span>
<span class="line"><span>    engine &#39;engine_name&#39;;</span></span></code></pre></div><p>​ 指定：</p><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>create table table_name tablespace tablespace_name;</span></span></code></pre></div><p><strong>Undo Tablespaces</strong>：撤销表空间</p><p>​ 会默认创建两个空间文件，undo001，undo002。主要存储undo Log 日志</p><p><strong>Temporary Tablespaces：</strong>：临时表空间</p><p>​ 存储用户创建的临时表</p><p><strong>Doublewrite Buffer Files</strong>：双写缓冲区</p><p>​ 从 Buffer pool 刷新到磁盘的数据会首先写入到双写缓冲区中，可以在系统崩溃时恢复数据</p><p><strong>Redo Log</strong>：重做日志</p><p>​ 用来实现事务的持久性，由两部分组成：重做日志缓冲（Redo Log Buffer），重做日志文件（Redo Log），前者在内存中，后者在 磁盘中。当事务提交之后会把信息存放在日志中，用于在刷新脏读页到磁盘，发生错误时，进行数据恢复</p><hr><h3 id="后台线程" tabindex="-1">后台线程 <a class="header-anchor" href="#后台线程" aria-label="Permalink to “后台线程”">​</a></h3><p>作用：将缓冲池中的数据在合适的时机刷新到磁盘文件中。</p><p><strong>Master Thread</strong>：核心后台线程 用于调度其他的线程，负责将缓冲池的数据异步刷新到磁盘中，脏页的刷新，合并插入缓存，undo页的回收</p><p><strong>IO Thread</strong>： 在InnoDB中使用了大量的<strong>AIO</strong>来处理IO请求，可以极大的提高效率，IO Thread用来负责这些IO请求的回调。 <img src="https://banxia-log.oss-cn-beijing.aliyuncs.com/MySQL/IO%20Thread%20%E7%9A%84%E7%BA%BF%E7%A8%8B%E7%B1%BB%E5%9E%8B.png" alt=""></p><p>​ <strong>AIO</strong>：异步非阻塞IO</p><p><strong>Purge Thread</strong>： 主要用于回收事务已经提交的undo Log，在事务提交之后，undo Log可能不会使用了，用这个线程回收</p><p><strong>Page cleaner Thread</strong>： 协助master Thread 进行脏页刷新，减轻主线程的工作压力，减少阻塞</p><hr><h2 id="事务原理" tabindex="-1">事务原理 <a class="header-anchor" href="#事务原理" aria-label="Permalink to “事务原理”">​</a></h2><p>我们通过事务的四大特性来解释事务的原理</p><p><strong>持久性</strong>：</p><p>由 redo Log 实现</p><p>​ <strong>redo Log</strong>：重做日志</p><p>​ 用来实现事务的持久性，由两部分组成：重做日志缓冲（Redo Log Buffer），重做日志文件（Redo Log），前者在内存中，后者在 磁盘中。当事务提交之后会把信息存放在日志中，用于在刷新脏读页到磁盘，发生错误时，进行数据恢复</p><p>在数据页从内存中被修改开始，这个数据页就变成脏页了，我们要把脏页写入到磁盘中，在这个过程中，如果出现问题导致写入失败，就会产生磁盘数据页和内存数据页不同步问题，持久性就不能保证了。</p><p>解决方法：我们可以通过重做日志将事务修改的信息存放到重做日志缓冲中，在脏页写入磁盘之前，将重做日志缓冲先写入到重做日志文件中，然后再开始脏页的写入，一旦写入发生错误，就可以调用重做日志文件中的内容将数据恢复。保证了事务的持久性</p><p>问题来了：你这个重做日志缓冲写入到重做日志文件的过程中发生错误时怎么办呢？既然会发生错误，那这玩意还有什么用呢？ 解答来了：由于脏页写入到磁盘中大部分都是随机写入，效率低下，时间段较长，而日志写入是追加写入，效率高，时间短，出现错误概 率低，就可以优化了，当然，点子背，那也没办法，只能依靠别的方式了。</p><p><strong>原子性</strong>：</p><p>由 undoLog 实现</p><p>​ <strong>undo Log</strong>：回滚日志</p><p>​ 记录的是数据被修改之前的信息，作用有两个，回滚和MVCC ​ 那么，既然要回滚，是不是也需要一个工具来实现这个数据-&gt;回滚的操作呢，毕竟数据不会自己写入到文件中。答案是并不用，redo Log存放的是物理数据，记录了改变后真正的数据值，而undo Log存放的是一条与当前操作相反的逻辑，如果删除，那我就插入，实 现百分百自主回滚！！！</p><p>​ undo Log 销毁：在事务结束的时候，不需要回滚的情况下，也不会立即删除 undo Log ，因为这些日志可能会用于 MVCC ​ undo Log 存储：采用段的方式进行管理和记录，存储在rollback segment 回滚段中，包含1024个undo Log 段</p><p>原子性最大的问题就是事务中只要有指令失败，就全部失败，那么前面执行成功的指令就要撤销，完成撤销工作的的就是undo Log了</p><p><strong>一致性</strong>：</p><p>意味：无论数据更新成功还是失败，数据都保持一致的状态！ 不是。持久性和原子性都实现了，一致性也就得到了保证（？</p><p><strong>隔离性</strong></p><p>由锁和MVCC实现</p><hr><h2 id="mvcc-多版本并发控制" tabindex="-1">MVCC 多版本并发控制 <a class="header-anchor" href="#mvcc-多版本并发控制" aria-label="Permalink to “MVCC 多版本并发控制”">​</a></h2><h3 id="概念" tabindex="-1">概念： <a class="header-anchor" href="#概念" aria-label="Permalink to “概念：”">​</a></h3><p><strong>当前读</strong>：会读取数据的最新版本，并保证读取过程中不被其他指令修改</p><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span># 下面两条语句都可以实现当前读</span></span>
<span class="line"><span>select ... lock in share mode (共享锁);</span></span>
<span class="line"><span>select ... for update; (update , insert , delete 都是排它锁)</span></span></code></pre></div><p><strong>快照读</strong>：简单的select就是快照读，快照是数据的可见版本，有可能是历史版，不加锁， 非阻塞读取</p><p>​ 下面是几种隔离方式对快照读的影响： ​ Read Committed：每次select都生成一个快照读 ​ Repeatable Read：开启事务之后，第一个select会生成一个快照 ​ Serializable：快读会退化成当前读</p><p><strong>MVCC</strong>：维护一个数据的多个版本，使得读写没有冲突，快照读为其实现提供了一个非阻塞的读功能，MVCC实现需要依赖数据库记录的 三个隐藏字段，undo Log，readView。</p><h3 id="实现原理" tabindex="-1">实现原理 <a class="header-anchor" href="#实现原理" aria-label="Permalink to “实现原理”">​</a></h3><h4 id="隐藏字段" tabindex="-1">隐藏字段 <a class="header-anchor" href="#隐藏字段" aria-label="Permalink to “隐藏字段”">​</a></h4><p><img src="https://banxia-log.oss-cn-beijing.aliyuncs.com/MySQL/MVCC%E9%9A%90%E8%97%8F%E5%AD%97%E6%AE%B5.png" alt=""></p><p>DB_TRX_ID：每次有事务修改本段时，会将本次事务的ID赋值给该字段 DB_ROLL_PTR：配合实现回滚 DB_ROW_ID：如果有主键，就不生成该字段</p><h4 id="undo-log版本链" tabindex="-1">undo_log版本链 <a class="header-anchor" href="#undo-log版本链" aria-label="Permalink to “undo_log版本链”">​</a></h4><p>回滚日志在insert时，产生的回滚记录只有在回滚的时候需要，事务完成，就可以被删除 在update，delete时，产生的回滚日志不仅仅在回滚的时候需要，在快照读的时候也需要，不会被立刻删除</p><p>不同的事务对同一行数据进行操作的时候，会在undo_log中生成一条版本链，版本链由隐藏字段中的回滚指针指向时间段更早的那一次记录，以便于实现数据恢复</p><p><img src="https://banxia-log.oss-cn-beijing.aliyuncs.com/MySQL/%E7%89%88%E6%9C%AC%E9%93%BE%E5%9B%BE%E8%A7%A3.png" alt=""></p><p>对于事务五的查询操作，查询到的数据到底是哪一个版本是依靠readview控制的</p><hr><h4 id="readview-读视图" tabindex="-1">readview：读视图 <a class="header-anchor" href="#readview-读视图" aria-label="Permalink to “readview：读视图”">​</a></h4><p>读视图为快照读功能的执行提供了数据依据，记录并维护当前活跃事务的ID 包含四个核心字段：<img src="https://banxia-log.oss-cn-beijing.aliyuncs.com/MySQL/readview%20%E8%AF%BB%E8%A7%86%E5%9B%BE%E6%A0%B8%E5%BF%83%E5%AD%97%E6%AE%B5.png" alt=""></p><p>在可重复读的隔离环境下，读视图会在每个事务第一次执行快照读的之前被创建，用于向快照读展示可以展示的数据，保证数据一致性 在RC隔离级别，由于每一次读取都是一次新的快照读，所以每一次都会生成一个readview。</p><p>访问规则： <img src="https://banxia-log.oss-cn-beijing.aliyuncs.com/MySQL/%E7%89%88%E6%9C%AC%E9%93%BE%E8%AE%BF%E9%97%AE%E8%A7%84%E5%88%99.png" alt=""></p><p>RC模式的实现原理：<img src="https://banxia-log.oss-cn-beijing.aliyuncs.com/MySQL/RC%E6%A8%A1%E5%BC%8F%E4%B8%8Breadview%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png" alt=""></p><p>RR模式的实现原理：<img src="https://banxia-log.oss-cn-beijing.aliyuncs.com/MySQL/RR%E6%A8%A1%E5%BC%8F%E4%B8%8Breadview%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png" alt=""></p><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to “总结”">​</a></h3><p>实现MVCC要依靠隐藏字段提供当前事务的ID信息，Undo log中的版本链提供历次更新数据事务的ID，ReadView提供的当前活跃事务的ID信息，综合三者来判断快照读应该读取到的版本</p><p>MVCC+锁 就可以保持数据的隔离性！！！</p><hr><h1 id="mysql管理" tabindex="-1">MySQL管理 <a class="header-anchor" href="#mysql管理" aria-label="Permalink to “MySQL管理”">​</a></h1><h2 id="系统数据库" tabindex="-1">系统数据库 <a class="header-anchor" href="#系统数据库" aria-label="Permalink to “系统数据库”">​</a></h2><p>在MySQL安装之后。会出现四个基础的数据库，由于每个版本带有的基础数据库不同，这里只展示8.0的数据库，<img src="https://banxia-log.oss-cn-beijing.aliyuncs.com/MySQL/MySQL8.0%E8%87%AA%E5%B8%A6%E6%95%B0%E6%8D%AE%E5%BA%93.png" alt=""></p><hr><h2 id="常用工具" tabindex="-1">常用工具 <a class="header-anchor" href="#常用工具" aria-label="Permalink to “常用工具”">​</a></h2><h3 id="mysql-经典客户端工具" tabindex="-1">mysql：经典客户端工具 <a class="header-anchor" href="#mysql-经典客户端工具" aria-label="Permalink to “mysql：经典客户端工具”">​</a></h3><p>此 mysql 并非 彼 mysql，这个不是指的是 mysql 服务，而是 mysql 客户端，可以使用脚本指令操作数据库，而不需要进行数据库服务登录。适用于脚本语言。<img src="https://banxia-log.oss-cn-beijing.aliyuncs.com/MySQL/mysql%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%8C%87%E4%BB%A4.png" alt=""></p><p>记得指定 database</p><hr><h3 id="mysqladmin-管理操作工具" tabindex="-1">mysqladmin：管理操作工具 <a class="header-anchor" href="#mysqladmin-管理操作工具" aria-label="Permalink to “mysqladmin：管理操作工具”">​</a></h3><p>mysqladmin 主要用来执行管理操作的客户端程序，可以用来检测服务器的配置和状态，创建库和删除库等</p><div class="language-cmd"><button title="Copy Code" class="copy"></button><span class="lang">cmd</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"># 这个客户端的指令参数有点多，可以通过 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">help查看帮助文档</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mysqladmin </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">help</span></span></code></pre></div><p>查看这个帮助文档，也不知道有啥，也不知道有没有中文的，懒得翻译了，随用随问AI吧</p><hr><h3 id="mysqlbinlog-二进制日志查看工具" tabindex="-1">mysqlbinlog：二进制日志查看工具 <a class="header-anchor" href="#mysqlbinlog-二进制日志查看工具" aria-label="Permalink to “mysqlbinlog：二进制日志查看工具”">​</a></h3><p>MySQL会生成二进制日志保存二进制信息。如果想要查看这些日志，需要这个日志管理工具<img src="https://banxia-log.oss-cn-beijing.aliyuncs.com/MySQL/mysqlbinlog%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95.png" alt=""></p><p>这里不细看，在运维篇比较详细</p><hr><h3 id="mysqlshow-客户端查询工具" tabindex="-1">mysqlshow：客户端查询工具 <a class="header-anchor" href="#mysqlshow-客户端查询工具" aria-label="Permalink to “mysqlshow：客户端查询工具”">​</a></h3><p>可以快速查询到有什么数据库，数据库的表，表的列，索引，统计信息等。<img src="https://banxia-log.oss-cn-beijing.aliyuncs.com/MySQL/mysqlshow%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95.png" alt="mysqlshow简单用法"></p><hr><h3 id="mysqldump-数据库备份工具" tabindex="-1">mysqldump：数据库备份工具 <a class="header-anchor" href="#mysqldump-数据库备份工具" aria-label="Permalink to “mysqldump：数据库备份工具”">​</a></h3><p>主要用于数据库的备份和数据迁移，备份内容有创建表，插入表的语句<img src="https://banxia-log.oss-cn-beijing.aliyuncs.com/MySQL/mysqldump%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95.png" alt=""></p><hr><h3 id="mysqlimport-sourec-数据库导入工具" tabindex="-1">mysqlimport / sourec 数据库导入工具 <a class="header-anchor" href="#mysqlimport-sourec-数据库导入工具" aria-label="Permalink to “mysqlimport / sourec 数据库导入工具”">​</a></h3><p>用来配合 mysqldump -T 输出的文件进行数据导入<img src="https://banxia-log.oss-cn-beijing.aliyuncs.com/MySQL/mysqlimport%20%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95.png" alt=""><img src="https://banxia-log.oss-cn-beijing.aliyuncs.com/MySQL/source%20%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95.png" alt=""></p><hr><h1 id="日志" tabindex="-1">日志 <a class="header-anchor" href="#日志" aria-label="Permalink to “日志”">​</a></h1><h2 id="错误日志" tabindex="-1">错误日志 <a class="header-anchor" href="#错误日志" aria-label="Permalink to “错误日志”">​</a></h2><p>见名知义，错误日志存放的是数据库在开始，结束，运行过程中出现错误时，记录相关信息的日志，如果数据库出现错误，停止运行，崩溃，建议首先查看错误日志。</p><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span># 存放目录：/var/log/mysqlld.log</span></span>
<span class="line"><span># 查看指令：</span></span>
<span class="line"><span>show variables like &#39;%log_error%&#39;;</span></span>
<span class="line"><span># 查看之后，log_error之后记录的是错误日志的路径</span></span></code></pre></div><hr><h2 id="二进制日志" tabindex="-1">二进制日志 <a class="header-anchor" href="#二进制日志" aria-label="Permalink to “二进制日志”">​</a></h2><p>二进制日志记录了所有的DDL，DML语句，不包括查询语句， 简单来说，包含的就是对库表的修改，元数据的修改，数据内容的修改 在MySQL8.x版本，二进制日志默认开启</p><h4 id="作用" tabindex="-1">作用： <a class="header-anchor" href="#作用" aria-label="Permalink to “作用：”">​</a></h4><p>1：灾难的数据恢复 2：主从复制</p><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span># 查看二进制日志参数\\</span></span>
<span class="line"><span>show variables like &#39;%log_bin%&#39;;</span></span>
<span class="line"><span># log_bin 是否开启</span></span>
<span class="line"><span># log_bin_basename 文件位置，文件名</span></span>
<span class="line"><span># log_bin_index 日志索引文件</span></span>
<span class="line"><span>...</span></span></code></pre></div><h4 id="格式" tabindex="-1">格式 <a class="header-anchor" href="#格式" aria-label="Permalink to “格式”">​</a></h4><p>二进制日志可以有多种记录方式：<img src="https://banxia-log.oss-cn-beijing.aliyuncs.com/MySQL/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97%E7%9A%84%E6%A0%BC%E5%BC%8F.png" alt=""></p><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span># 查询参数方式</span></span>
<span class="line"><span>show variables like &#39;%binlog_format%&#39;;</span></span></code></pre></div><p><img src="https://banxia-log.oss-cn-beijing.aliyuncs.com/MySQL/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97%E6%9F%A5%E7%9C%8B%E6%96%B9%E5%BC%8F.png" alt=""></p><p>那么问题就来了：二进制日志太多，时间线太长，怎么办：我们可以删除</p><p><img src="https://banxia-log.oss-cn-beijing.aliyuncs.com/MySQL/%E5%88%A0%E9%99%A4%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97%E6%96%B9%E5%BC%8F.png" alt=""></p><hr><h2 id="查询日志" tabindex="-1">查询日志 <a class="header-anchor" href="#查询日志" aria-label="Permalink to “查询日志”">​</a></h2><p>二进制日志中包含的是DML和DDL语句，查询日志包含所有的语句 由于记录语句太多，查询语句一般不默认开启，要手动开启</p><div class="language-mysql"><button title="Copy Code" class="copy"></button><span class="lang">mysql</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span># 查看参数</span></span>
<span class="line"><span>show variables like &#39;%general%&#39;;</span></span></code></pre></div><p>开启方法：<img src="https://banxia-log.oss-cn-beijing.aliyuncs.com/MySQL/%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E5%BC%80%E5%90%AF%E6%96%B9%E6%B3%95.png" alt=""></p><hr><h2 id="慢查询日志-1" tabindex="-1">慢查询日志 <a class="header-anchor" href="#慢查询日志-1" aria-label="Permalink to “慢查询日志”">​</a></h2><p>之前了解过，指的是记录那些超过预定耗时的语句，所以叫慢查询日志。默认不开启</p><p>开启：<img src="https://banxia-log.oss-cn-beijing.aliyuncs.com/MySQL/%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E5%BC%80%E5%90%AF%E6%96%B9%E6%B3%95.png" alt=""></p><p>默认情况下，慢查询日志不会记录管理语句，也不会记录不使用索引的语句，但是可以开启：<img src="https://banxia-log.oss-cn-beijing.aliyuncs.com/MySQL/%E5%A6%82%E4%BD%95%E6%9B%B4%E6%94%B9%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E7%9A%84%E8%AE%B0%E5%BD%95%E8%A7%84%E5%88%99.png" alt=""></p><h1 id="主从复制" tabindex="-1">主从复制 <a class="header-anchor" href="#主从复制" aria-label="Permalink to “主从复制”">​</a></h1><h2 id="概述" tabindex="-1">概述 <a class="header-anchor" href="#概述" aria-label="Permalink to “概述”">​</a></h2><p>将主库的二进制日志导出，写入一个新的数据库，就是主从复制，提供二进制日志的数据库叫做主库，接受二进制日志的叫做从库</p><h3 id="作用-1" tabindex="-1">作用： <a class="header-anchor" href="#作用-1" aria-label="Permalink to “作用：”">​</a></h3><p>1：主库出现问题，可以切换到从库进行服务 2：实现读写分离，降低主库压力 3：可以在从库中进行备份，避免备份期间影响服务</p><hr><h2 id="原理" tabindex="-1">原理 <a class="header-anchor" href="#原理" aria-label="Permalink to “原理”">​</a></h2><p>主从复制的原理是基于二进制日志（binlog）</p><p>首先，主库会导出一份binlog，以供从库接收 然后，从库会创建IOThread，用于发送请求，读取主库导出的binlog，并写入到一份中继日志（Relay log）中 然后，从库会创建SQLThread 用于将中继日志的信息写入到数据库中</p><h2 id="搭建" tabindex="-1">搭建 <a class="header-anchor" href="#搭建" aria-label="Permalink to “搭建”">​</a></h2><p>首先，搭建需要两台服务器。一台搭载主库，一台搭载从库 然后，需要关闭两台服务器的防火墙或者开放指定端口<img src="https://banxia-log.oss-cn-beijing.aliyuncs.com/MySQL/%E5%BC%80%E6%94%BE%E7%AB%AF%E5%8F%A3%E5%92%8C%E5%85%B3%E9%97%AD%E9%98%B2%E7%81%AB%E5%A2%99.png" alt=""> 然后，配置主库：修改文件：<img src="https://banxia-log.oss-cn-beijing.aliyuncs.com/MySQL/%E4%B8%BB%E5%BA%93%E9%85%8D%E7%BD%AE.png" alt="主库配置"> 然后：配置主库：创建账户：<img src="https://banxia-log.oss-cn-beijing.aliyuncs.com/MySQL/%E5%88%9B%E5%BB%BA%E4%B8%BB%E5%BA%93%E8%B4%A6%E6%88%B7.png" alt=""> 然后：查看主库二进制日志坐标：<img src="https://banxia-log.oss-cn-beijing.aliyuncs.com/MySQL/%E4%B8%BB%E5%BA%93%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97%E5%9D%90%E6%A0%87.png" alt=""> 然后：修改从库文件：<img src="https://banxia-log.oss-cn-beijing.aliyuncs.com/MySQL/%E4%BB%8E%E5%BA%93%E6%96%87%E4%BB%B6%E4%BF%AE%E6%94%B9.png" alt="">如果想禁用超级管理员权限，需要加入：super_read_only=1 然后，在从库设置主库配置：<img src="https://banxia-log.oss-cn-beijing.aliyuncs.com/MySQL/%E4%BB%8E%E5%BA%93%E9%85%8D%E7%BD%AE.png" alt=""> 然后：开启从库同步操作：| <img src="https://banxia-log.oss-cn-beijing.aliyuncs.com/MySQL/%E4%BB%8E%E5%BA%93%E5%BC%80%E5%90%AF%E6%93%8D%E4%BD%9C.png" alt=""> 然后：还可以检查从库状态： <img src="https://banxia-log.oss-cn-beijing.aliyuncs.com/MySQL/%E4%BB%8E%E5%BA%93%E5%90%8C%E6%AD%A5%E7%8A%B6%E6%80%81.png" alt=""></p><hr><h1 id="分库分表" tabindex="-1">分库分表 <a class="header-anchor" href="#分库分表" aria-label="Permalink to “分库分表”">​</a></h1><p>随着服务器的发展，应用数据量也会日益增多，若采用单个数据库存储，会存在以下瓶颈： 1：IO瓶颈：热点数据太多，存放热点数据的缓存区不足，就会使用磁盘，产生大量IO，速度大大降低，请求数据太多，网络延迟。带宽不足，造成严重的IO瓶颈。 2：CPU瓶颈：排序，分组，连接查询，聚合统计会消耗掉大量的CPU资源，请求次数太多，CPU性能出现瓶颈</p><p>为了减轻这两个瓶颈产生的影响，我们发明了分库分表操作</p><p>核心思想就是通过将数据库的数据分散到不同数据库的操作来减轻这种影响，提升性能</p><hr><h2 id="拆分策略" tabindex="-1">拆分策略 <a class="header-anchor" href="#拆分策略" aria-label="Permalink to “拆分策略”">​</a></h2><h3 id="垂直拆分" tabindex="-1">垂直拆分 <a class="header-anchor" href="#垂直拆分" aria-label="Permalink to “垂直拆分”">​</a></h3><h4 id="垂直分库" tabindex="-1">垂直分库 <a class="header-anchor" href="#垂直分库" aria-label="Permalink to “垂直分库”">​</a></h4><p>以表为依据，根据业务不同将不同的表拆分到不同的表中</p><p>特点： 每个表的结构不一样 每个表的数据不一样 表的并集是全部数据</p><h4 id="垂直分表" tabindex="-1">垂直分表 <a class="header-anchor" href="#垂直分表" aria-label="Permalink to “垂直分表”">​</a></h4><p>以字段为依据，依据不同的字段将数据拆分到不同的表中</p><p>特点： 每个表的结构不一样 每个表的数据也不一样，一般通过主键实现数据配对 所有表的数据的并集是全量数据</p><h3 id="水平拆分" tabindex="-1">水平拆分 <a class="header-anchor" href="#水平拆分" aria-label="Permalink to “水平拆分”">​</a></h3><h4 id="水平分库" tabindex="-1">水平分库 <a class="header-anchor" href="#水平分库" aria-label="Permalink to “水平分库”">​</a></h4><p>按照字段数据为依据，将数据拆分到不同的数据库中 也就是说，不同的数据库中的表结构相同，数据被拆分到不同的表中</p><p>特点： 数据的表结构都一样 表中的数据不一样 所有数据的并集就是全数据</p><h4 id="水平分表" tabindex="-1">水平分表 <a class="header-anchor" href="#水平分表" aria-label="Permalink to “水平分表”">​</a></h4><p>和水平分库差不多。也是将数据分配到不同的表中</p><p>特点： 表结构一样 数据不一样 并集是全部数据</p><hr><h2 id="mycat" tabindex="-1">Mycat <a class="header-anchor" href="#mycat" aria-label="Permalink to “Mycat”">​</a></h2><p>mycat是数据库连接的中间件，可以像使用mysql一样使用这个中间件，开发者感知不到mycat的存在 mycat伪装了MySQL的协议， 用户可以无缝更换mycat</p><p>优势： 性能稳定 强大的技术团队 体系完善 社区活跃</p><h1 id="不知道是啥的知识点" tabindex="-1">不知道是啥的知识点 <a class="header-anchor" href="#不知道是啥的知识点" aria-label="Permalink to “不知道是啥的知识点”">​</a></h1><p>使得该字段自动增加数字：auto_increment 可以用于编号的自动增加</p><pre><code>查看配置参数：show variables like &#39;参数&#39;;
    InnoDB的表文件共用：innodb_file_per_table
</code></pre><hr><h2 id="页合并阈值" tabindex="-1">页合并阈值 <a class="header-anchor" href="#页合并阈值" aria-label="Permalink to “页合并阈值”">​</a></h2><p>merge_threshold：合并阈值，在创建表或者索引时指定</p>`,885)])])}const b=s(l,[["render",t]]);export{g as __pageData,b as default};
