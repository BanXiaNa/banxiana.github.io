<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Java集合笔记 | XIA</title>
    <meta name="description" content="探索……沉淀……成长！分享技术学习笔记和实践经验">
    <meta name="generator" content="VitePress v2.0.0-alpha.15">
    <link rel="preload stylesheet" href="/assets/style.IqmFYGER.css" as="style">
    <link rel="preload stylesheet" href="/vp-icons.css" as="style">
    
    <script type="module" src="/assets/app.CGjUGiOz.js"></script>
    <link rel="preload" href="/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/assets/chunks/theme.CToUuDwF.js">
    <link rel="modulepreload" href="/assets/chunks/framework.CbWvOqpl.js">
    <link rel="modulepreload" href="/assets/pages_Articles_InterviewNotes_Java_JavaCollection_JavaCollection.md.B8DJYqxa.lean.js">
    <link rel="icon" href="/favicon.ico">
    <meta name="keywords" content="MySQL, Spring, 设计模式, Java, 技术博客, 编程, 数据库">
    <meta name="author" content="XIA">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://pinellia.cn/">
    <meta property="og:site_name" content="XIA 技术博客">
    <meta property="og:title" content="XIA - 个人技术博客">
    <meta property="og:description" content="探索……沉淀……成长！分享技术学习笔记和实践经验">
    <meta property="og:image" content="https://pinellia.cn/logo.png">
    <meta property="og:image:type" content="image/png">
    <meta property="og:image:width" content="800">
    <meta property="og:image:height" content="800">
    <meta property="og:image:alt" content="XIA 技术博客">
    <meta property="og:locale" content="zh_CN">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@XIA">
    <meta name="twitter:title" content="XIA - 个人技术博客">
    <meta name="twitter:description" content="探索……沉淀……成长！分享技术学习笔记和实践经验">
    <meta name="twitter:image" content="https://pinellia.cn/logo.png">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-1df9f90f><!--[--><!--]--><!--[--><span tabindex="-1" data-v-331ec75c></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-331ec75c>Skip to content</a><!--]--><!----><header class="VPNav" data-v-1df9f90f data-v-da52a441><div class="VPNavBar" data-v-da52a441 data-v-70946a35><div class="wrapper" data-v-70946a35><div class="container" data-v-70946a35><div class="title" data-v-70946a35><div class="VPNavBarTitle has-sidebar" data-v-70946a35 data-v-1e38c6bc><a class="title" href="/" data-v-1e38c6bc><!--[--><!--]--><!--[--><img class="VPImage logo" src="/logo.svg" alt data-v-8426fc1a><!--]--><span data-v-1e38c6bc>XIA</span><!--[--><!--]--></a></div></div><div class="content" data-v-70946a35><div class="content-body" data-v-70946a35><!--[--><!--]--><div class="VPNavBarSearch search" data-v-70946a35><!--[--><!----><div id="local-search"><button type="button" aria-label="Search" aria-keyshortcuts="/ control+k meta+k" class="DocSearch DocSearch-Button"><span class="DocSearch-Button-Container"><span class="vpi-search DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key"></kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-70946a35 data-v-39714824><span id="main-nav-aria-label" class="visually-hidden" data-v-39714824> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/" tabindex="0" data-v-39714824 data-v-52a1d768><!--[--><span data-v-52a1d768>🏡 我的主页</span><!--]--></a><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-39714824 data-v-42cb505d><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-42cb505d><span class="text" data-v-42cb505d><!----><span data-v-42cb505d>📝 我的文章</span><span class="vpi-chevron-down text-icon" data-v-42cb505d></span></span></button><div class="menu" data-v-42cb505d><div class="VPMenu" data-v-42cb505d data-v-25a6cce8><div class="items" data-v-25a6cce8><!--[--><!--[--><div class="VPMenuLink" data-v-25a6cce8 data-v-faf5b206><a class="VPLink link" href="/pages/Articles/InterviewNotes/" data-v-faf5b206><!--[--><span data-v-faf5b206>📚 面试笔记</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-25a6cce8 data-v-faf5b206><a class="VPLink link" href="/pages/Articles/DesignPattern/DesignPattern.html" data-v-faf5b206><!--[--><span data-v-faf5b206>📐 设计模式</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-25a6cce8 data-v-faf5b206><a class="VPLink link" href="/pages/Articles/GitCommitConventions/GitCommitConventions.html" data-v-faf5b206><!--[--><span data-v-faf5b206>📋 Git 提交规范</span><!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-39714824 data-v-42cb505d><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-42cb505d><span class="text" data-v-42cb505d><!----><span data-v-42cb505d>📖 我的文档</span><span class="vpi-chevron-down text-icon" data-v-42cb505d></span></span></button><div class="menu" data-v-42cb505d><div class="VPMenu" data-v-42cb505d data-v-25a6cce8><div class="items" data-v-25a6cce8><!--[--><!--[--><div class="VPMenuLink" data-v-25a6cce8 data-v-faf5b206><a class="VPLink link" href="/pages/Documents/SpringNotes/" data-v-faf5b206><!--[--><span data-v-faf5b206>🌱 Spring 小记</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-25a6cce8 data-v-faf5b206><a class="VPLink link" href="/pages/Documents/SQL/" data-v-faf5b206><!--[--><span data-v-faf5b206>🗄️ MySQL 数据库</span><!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-39714824 data-v-42cb505d><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-42cb505d><span class="text" data-v-42cb505d><!----><span data-v-42cb505d>🗞 杂货</span><span class="vpi-chevron-down text-icon" data-v-42cb505d></span></span></button><div class="menu" data-v-42cb505d><div class="VPMenu" data-v-42cb505d data-v-25a6cce8><div class="items" data-v-25a6cce8><!--[--><!--[--><div class="VPMenuLink" data-v-25a6cce8 data-v-faf5b206><a class="VPLink link" href="/pages/Groceries/MAGAOPythonNotesS1.html" data-v-faf5b206><!--[--><span data-v-faf5b206>🐍 Python 基础教程</span><!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/pages/Music/" tabindex="0" data-v-39714824 data-v-52a1d768><!--[--><span data-v-52a1d768>🎵 音乐站</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-70946a35 data-v-6c893767><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-6c893767 data-v-5337faa4 data-v-1d5665e3><span class="check" data-v-1d5665e3><span class="icon" data-v-1d5665e3><!--[--><span class="vpi-sun sun" data-v-5337faa4></span><span class="vpi-moon moon" data-v-5337faa4></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-70946a35 data-v-0394ad82 data-v-d07f11e6><!--[--><a class="VPSocialLink no-icon" href="https://github.com/BanXiaNa" aria-label="github" target="_blank" rel="me noopener" data-v-d07f11e6 data-v-591a6b30><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-70946a35 data-v-bf2fac68 data-v-42cb505d><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-42cb505d><span class="vpi-more-horizontal icon" data-v-42cb505d></span></button><div class="menu" data-v-42cb505d><div class="VPMenu" data-v-42cb505d data-v-25a6cce8><!----><!--[--><!--[--><!----><div class="group" data-v-bf2fac68><div class="item appearance" data-v-bf2fac68><p class="label" data-v-bf2fac68>Appearance</p><div class="appearance-action" data-v-bf2fac68><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-bf2fac68 data-v-5337faa4 data-v-1d5665e3><span class="check" data-v-1d5665e3><span class="icon" data-v-1d5665e3><!--[--><span class="vpi-sun sun" data-v-5337faa4></span><span class="vpi-moon moon" data-v-5337faa4></span><!--]--></span></span></button></div></div></div><div class="group" data-v-bf2fac68><div class="item social-links" data-v-bf2fac68><div class="VPSocialLinks social-links-list" data-v-bf2fac68 data-v-d07f11e6><!--[--><a class="VPSocialLink no-icon" href="https://github.com/BanXiaNa" aria-label="github" target="_blank" rel="me noopener" data-v-d07f11e6 data-v-591a6b30><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-70946a35 data-v-e5dd9c1c><span class="container" data-v-e5dd9c1c><span class="top" data-v-e5dd9c1c></span><span class="middle" data-v-e5dd9c1c></span><span class="bottom" data-v-e5dd9c1c></span></span></button></div></div></div></div><div class="divider" data-v-70946a35><div class="divider-line" data-v-70946a35></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-1df9f90f data-v-db738f89><div class="container" data-v-db738f89><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-db738f89><span class="vpi-align-left menu-icon" data-v-db738f89></span><span class="menu-text" data-v-db738f89>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-db738f89 data-v-0bf0e06f><button data-v-0bf0e06f>返回顶部</button><!----></div></div></div><aside class="VPSidebar" data-v-1df9f90f data-v-af661f50><div class="curtain" data-v-af661f50></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-af661f50><span class="visually-hidden" id="sidebar-aria-label" data-v-af661f50> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-8d50c081><section class="VPSidebarItem level-0 has-active" data-v-8d50c081 data-v-d81de50c><div class="item" role="button" tabindex="0" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><h2 class="text" data-v-d81de50c>📝 我的文章</h2><!----></div><div class="items" data-v-d81de50c><!--[--><section class="VPSidebarItem level-1 collapsible is-link has-active" data-v-d81de50c data-v-d81de50c><div class="item" tabindex="0" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/pages/Articles/InterviewNotes/" data-v-d81de50c><!--[--><h3 class="text" data-v-d81de50c>面试笔记</h3><!--]--></a><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-d81de50c><span class="vpi-chevron-right caret-icon" data-v-d81de50c></span></div></div><div class="items" data-v-d81de50c><!--[--><section class="VPSidebarItem level-2 collapsible has-active" data-v-d81de50c data-v-d81de50c><div class="item" role="button" tabindex="0" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><h4 class="text" data-v-d81de50c>Java 技术栈</h4><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-d81de50c><span class="vpi-chevron-right caret-icon" data-v-d81de50c></span></div></div><div class="items" data-v-d81de50c><!--[--><div class="VPSidebarItem level-3 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/pages/Articles/InterviewNotes/Java/JavaBasic/JavaBasic.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>Java 基础</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-3 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/pages/Articles/InterviewNotes/Java/JavaCollection/JavaCollection.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>Java 集合框架</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-3 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/pages/Articles/InterviewNotes/Java/JavaConcurrency/JavaConcurrency.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>Java 并发编程</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-3 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/pages/Articles/InterviewNotes/Java/JVM/JVM.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>JVM 虚拟机</p><!--]--></a><!----></div><!----></div><!--]--></div></section><section class="VPSidebarItem level-2 collapsible" data-v-d81de50c data-v-d81de50c><div class="item" role="button" tabindex="0" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><h4 class="text" data-v-d81de50c>中间件技术</h4><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-d81de50c><span class="vpi-chevron-right caret-icon" data-v-d81de50c></span></div></div><div class="items" data-v-d81de50c><!--[--><div class="VPSidebarItem level-3 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/pages/Articles/InterviewNotes/Redis/RedisNotes.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>Redis 笔记</p><!--]--></a><!----></div><!----></div><!--]--></div></section><!--]--></div></section><section class="VPSidebarItem level-1 collapsible is-link" data-v-d81de50c data-v-d81de50c><div class="item" tabindex="0" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/pages/Articles/DesignPattern/DesignPattern.html" data-v-d81de50c><!--[--><h3 class="text" data-v-d81de50c>设计模式</h3><!--]--></a><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-d81de50c><span class="vpi-chevron-right caret-icon" data-v-d81de50c></span></div></div><div class="items" data-v-d81de50c><!--[--><section class="VPSidebarItem level-2 collapsible" data-v-d81de50c data-v-d81de50c><div class="item" role="button" tabindex="0" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><h4 class="text" data-v-d81de50c>创建型设计模式</h4><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-d81de50c><span class="vpi-chevron-right caret-icon" data-v-d81de50c></span></div></div><div class="items" data-v-d81de50c><!--[--><div class="VPSidebarItem level-3 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/pages/Articles/DesignPattern/CreationalPattern/FactoryPattern/FactoryPattern.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>工厂模式</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-3 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/pages/Articles/DesignPattern/CreationalPattern/SingletonPattern/SingletonPattern.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>单例模式</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-3 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/pages/Articles/DesignPattern/CreationalPattern/BuilderPattern/BuilderPattern.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>建造者模式</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-3 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/pages/Articles/DesignPattern/CreationalPattern/PrototypePattern/PrototypePattern.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>原型模式</p><!--]--></a><!----></div><!----></div><!--]--></div></section><section class="VPSidebarItem level-2 collapsible" data-v-d81de50c data-v-d81de50c><div class="item" role="button" tabindex="0" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><h4 class="text" data-v-d81de50c>结构型设计模式</h4><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-d81de50c><span class="vpi-chevron-right caret-icon" data-v-d81de50c></span></div></div><div class="items" data-v-d81de50c><!--[--><div class="VPSidebarItem level-3 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/pages/Articles/DesignPattern/StructuralPattern/AdapterPattern/AdapterPattern.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>适配器模式</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-3 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/pages/Articles/DesignPattern/StructuralPattern/BridgePattern/BridgePattern.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>桥接模式</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-3 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/pages/Articles/DesignPattern/StructuralPattern/FilterPattern/FilterPattern.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>过滤器模式</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-3 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/pages/Articles/DesignPattern/StructuralPattern/CompositePattern/CompositePattern.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>组合模式</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-3 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/pages/Articles/DesignPattern/StructuralPattern/DecoratorPattern/DecoratorPattern.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>装饰器模式</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-3 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/pages/Articles/DesignPattern/StructuralPattern/FacadePattern/FacadePattern.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>外观模式</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-3 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/pages/Articles/DesignPattern/StructuralPattern/FlyweightPattern/FlyweightPattern.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>享元模式</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-3 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/pages/Articles/DesignPattern/StructuralPattern/ProxyPattern/ProxyPattern.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>代理模式</p><!--]--></a><!----></div><!----></div><!--]--></div></section><section class="VPSidebarItem level-2 collapsible" data-v-d81de50c data-v-d81de50c><div class="item" role="button" tabindex="0" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><h4 class="text" data-v-d81de50c>行为型设计模式</h4><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-d81de50c><span class="vpi-chevron-right caret-icon" data-v-d81de50c></span></div></div><div class="items" data-v-d81de50c><!--[--><div class="VPSidebarItem level-3 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/pages/Articles/DesignPattern/BehavioralPattern/ChainOfResponsibilityPattern/ChainOfResponsibilityPattern.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>责任链模式</p><!--]--></a><!----></div><!----></div><!--]--></div></section><!--]--></div></section><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/pages/Articles/GitCommitConventions/GitCommitConventions.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>Git 提交规范</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-8d50c081><section class="VPSidebarItem level-0" data-v-8d50c081 data-v-d81de50c><div class="item" role="button" tabindex="0" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><h2 class="text" data-v-d81de50c>📖 我的文档</h2><!----></div><div class="items" data-v-d81de50c><!--[--><section class="VPSidebarItem level-1 collapsible is-link" data-v-d81de50c data-v-d81de50c><div class="item" tabindex="0" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/pages/Documents/SpringNotes/" data-v-d81de50c><!--[--><h3 class="text" data-v-d81de50c>Spring 小记</h3><!--]--></a><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-d81de50c><span class="vpi-chevron-right caret-icon" data-v-d81de50c></span></div></div><div class="items" data-v-d81de50c><!--[--><section class="VPSidebarItem level-2 collapsible" data-v-d81de50c data-v-d81de50c><div class="item" role="button" tabindex="0" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><h4 class="text" data-v-d81de50c>Spring MVC</h4><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-d81de50c><span class="vpi-chevron-right caret-icon" data-v-d81de50c></span></div></div><div class="items" data-v-d81de50c><!--[--><div class="VPSidebarItem level-3 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/pages/Documents/SpringNotes/SpringMVC/ResponseBodyEmitter.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>ResponseBodyEmitter 使用</p><!--]--></a><!----></div><!----></div><!--]--></div></section><!--]--></div></section><section class="VPSidebarItem level-1 collapsible is-link" data-v-d81de50c data-v-d81de50c><div class="item" tabindex="0" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/pages/Documents/SQL/" data-v-d81de50c><!--[--><h3 class="text" data-v-d81de50c>MySQL 数据库</h3><!--]--></a><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-d81de50c><span class="vpi-chevron-right caret-icon" data-v-d81de50c></span></div></div><div class="items" data-v-d81de50c><!--[--><section class="VPSidebarItem level-2 collapsible collapsed" data-v-d81de50c data-v-d81de50c><div class="item" role="button" tabindex="0" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><h4 class="text" data-v-d81de50c>🎯 基础篇</h4><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-d81de50c><span class="vpi-chevron-right caret-icon" data-v-d81de50c></span></div></div><div class="items" data-v-d81de50c><!--[--><div class="VPSidebarItem level-3 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/pages/Documents/SQL/01%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%8C%87%E4%BB%A4.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>01：基础指令</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-3 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/pages/Documents/SQL/02%EF%BC%9A%E5%87%BD%E6%95%B0.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>02：函数</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-3 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/pages/Documents/SQL/03%EF%BC%9A%E7%BA%A6%E6%9D%9F.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>03：约束</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-3 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/pages/Documents/SQL/04%EF%BC%9A%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>04：多表查询</p><!--]--></a><!----></div><!----></div><!--]--></div></section><section class="VPSidebarItem level-2 collapsible collapsed" data-v-d81de50c data-v-d81de50c><div class="item" role="button" tabindex="0" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><h4 class="text" data-v-d81de50c>🚀 进阶篇</h4><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-d81de50c><span class="vpi-chevron-right caret-icon" data-v-d81de50c></span></div></div><div class="items" data-v-d81de50c><!--[--><div class="VPSidebarItem level-3 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/pages/Documents/SQL/05%EF%BC%9A%E4%BA%8B%E5%8A%A1.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>05：事务</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-3 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/pages/Documents/SQL/06%EF%BC%9A%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>06：存储引擎</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-3 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/pages/Documents/SQL/07%EF%BC%9A%E7%B4%A2%E5%BC%95.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>07：索引</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-3 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/pages/Documents/SQL/08%EF%BC%9A%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>08：性能分析</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-3 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/pages/Documents/SQL/09%EF%BC%9ASQL%E4%BC%98%E5%8C%96.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>09：SQL优化</p><!--]--></a><!----></div><!----></div><!--]--></div></section><section class="VPSidebarItem level-2 collapsible collapsed" data-v-d81de50c data-v-d81de50c><div class="item" role="button" tabindex="0" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><h4 class="text" data-v-d81de50c>💎 高级篇</h4><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-d81de50c><span class="vpi-chevron-right caret-icon" data-v-d81de50c></span></div></div><div class="items" data-v-d81de50c><!--[--><div class="VPSidebarItem level-3 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/pages/Documents/SQL/10%EF%BC%9A%E8%A7%86%E5%9B%BE.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>10：视图</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-3 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/pages/Documents/SQL/11%EF%BC%9A%E5%AD%98%E5%82%A8.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>11：存储</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-3 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/pages/Documents/SQL/12%EF%BC%9A%E8%A7%A6%E5%8F%91%E5%99%A8.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>12：触发器</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-3 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/pages/Documents/SQL/13%EF%BC%9A%E9%94%81.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>13：锁</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-3 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/pages/Documents/SQL/14%EF%BC%9AInnoDB.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>14：InnoDB</p><!--]--></a><!----></div><!----></div><!--]--></div></section><section class="VPSidebarItem level-2 collapsible collapsed" data-v-d81de50c data-v-d81de50c><div class="item" role="button" tabindex="0" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><h4 class="text" data-v-d81de50c>🔧 运维篇</h4><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-d81de50c><span class="vpi-chevron-right caret-icon" data-v-d81de50c></span></div></div><div class="items" data-v-d81de50c><!--[--><div class="VPSidebarItem level-3 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/pages/Documents/SQL/15%EF%BC%9AMySQL%E7%AE%A1%E7%90%86.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>15：MySQL管理</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-3 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/pages/Documents/SQL/16%EF%BC%9A%E6%97%A5%E5%BF%97.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>16：日志</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-3 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/pages/Documents/SQL/17%EF%BC%9A%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>17：主从复制</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-3 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/pages/Documents/SQL/18%EF%BC%9A%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>18：分库分表</p><!--]--></a><!----></div><!----></div><!--]--></div></section><!--]--></div></section><!--]--></div></section></div><div class="no-transition group" data-v-8d50c081><section class="VPSidebarItem level-0" data-v-8d50c081 data-v-d81de50c><div class="item" role="button" tabindex="0" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><h2 class="text" data-v-d81de50c>🗞 杂货</h2><!----></div><div class="items" data-v-d81de50c><!--[--><div class="VPSidebarItem level-1 is-link" data-v-d81de50c data-v-d81de50c><div class="item" data-v-d81de50c><div class="indicator" data-v-d81de50c></div><a class="VPLink link link" href="/pages/Groceries/MAGAOPythonNotesS1.html" data-v-d81de50c><!--[--><p class="text" data-v-d81de50c>Python 基础教程</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-1df9f90f data-v-c87f25bf><div class="VPDoc has-sidebar has-aside" data-v-c87f25bf data-v-7011f0d8><!--[--><!--]--><div class="container" data-v-7011f0d8><div class="aside" data-v-7011f0d8><div class="aside-curtain" data-v-7011f0d8></div><div class="aside-container" data-v-7011f0d8><div class="aside-content" data-v-7011f0d8><div class="VPDocAside" data-v-7011f0d8 data-v-3f215769><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-3f215769 data-v-60d5052e><div class="content" data-v-60d5052e><div class="outline-marker" data-v-60d5052e></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-60d5052e>目录</div><ul class="VPDocOutlineItem root" data-v-60d5052e data-v-1ce71065><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-3f215769></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-7011f0d8><div class="content-container" data-v-7011f0d8><!--[--><!--[--><!--[--><!----><!--]--><!--]--><!--]--><main class="main" data-v-7011f0d8><div style="position:relative;" class="vp-doc _pages_Articles_InterviewNotes_Java_JavaCollection_JavaCollection" data-v-7011f0d8><div><h1 id="java集合笔记" tabindex="-1">Java集合笔记 <a class="header-anchor" href="#java集合笔记" aria-label="Permalink to “Java集合笔记”">​</a></h1><p><img src="https://banxia-log.oss-cn-beijing.aliyuncs.com/Java%E5%85%AB%E8%82%A1/Collection%E7%BB%93%E6%9E%84.png" alt=""></p><h1 id="概述" tabindex="-1">概述： <a class="header-anchor" href="#概述" aria-label="Permalink to “概述：”">​</a></h1><h2 id="数组与集合的区别" tabindex="-1">数组与集合的区别？ <a class="header-anchor" href="#数组与集合的区别" aria-label="Permalink to “数组与集合的区别？”">​</a></h2><table tabindex="0"><thead><tr><th style="text-align:center;"><strong>特性</strong></th><th style="text-align:center;"><strong>数组 (Array)</strong></th><th style="text-align:center;"><strong>集合 (Collection/List)</strong></th></tr></thead><tbody><tr><td style="text-align:center;"><strong>容量大小</strong></td><td style="text-align:center;"><strong>固定</strong>。一旦创建，长度不可改变。</td><td style="text-align:center;"><strong>动态</strong>。可以根据需要自动扩容或缩减。</td></tr><tr><td style="text-align:center;"><strong>存储类型</strong></td><td style="text-align:center;">既可以存<strong>基本数据类型</strong>（int, double），也可以存<strong>对象</strong>。</td><td style="text-align:center;">通常只能存<strong>对象</strong>（基本类型会被自动装箱为包装类）。</td></tr><tr><td style="text-align:center;"><strong>性能</strong></td><td style="text-align:center;"><strong>极高</strong>。因为内存连续，访问速度最快。</td><td style="text-align:center;"><strong>较高</strong>。但由于有额外的管理开销，略逊于数组。</td></tr><tr><td style="text-align:center;"><strong>访问方式</strong></td><td style="text-align:center;">支持直接访问</td><td style="text-align:center;">通过迭代器访问</td></tr><tr><td style="text-align:center;"><strong>功能扩展</strong></td><td style="text-align:center;">功能单一，仅提供 <code>.length</code> 和索引访问。</td><td style="text-align:center;"><strong>丰富</strong>。提供排序、搜索、去重、各种算法接口。</td></tr></tbody></table><h2 id="说说集合" tabindex="-1">说说集合？ <a class="header-anchor" href="#说说集合" aria-label="Permalink to “说说集合？”">​</a></h2><p>集合框架分为两个体系：实现 Collection 接口的单列体系，实现 Map 的双列体系</p><p><strong>Collection：</strong>作为单列集合的顶层接口，定义了增删改查等基础接口，同时，它继承了 <strong>Iterable</strong> 接口，所以也能使用迭代器进行遍历</p><ul><li><strong>List：</strong>有序，有索引，可重复的集合，常用：ArrayList，LinkedList <ul><li><strong>ArrayList：</strong>容量可变，线程不安全，底层是数组，所以随机访问速度快，增删速度慢</li><li><strong>LinkedList：</strong>容量可变，线程不安全，双向链表，所以增删快，随机访问慢</li></ul></li><li><strong>Set：</strong>无序，不可重复，常用：HashSet，LinkedHashSet和TreeSet <ul><li><strong>HashSet：</strong>无序，唯一，高性能，线程不安全，通过 HashMap 实现，存储的值就是Map的Key，与之对应的V，就是一个名为 <code>PRESENT</code> 的 Object 对象</li><li><strong>LinkedHashSet：</strong>有序，唯一，性能略低，线程不安全，通过 HashSet + LinkedList 实现，哈希表负责唯一性，双向链表负责有序性</li><li><strong>TreeSet：</strong>排序，唯一，不允许NULL，通过 TreeMap 实现底层，保证排序，可以自定义规则</li></ul></li></ul><p><strong>Map：</strong>作为双列集合的顶层接口，同样也定义了一些增删改查接口，Map的每一个条目包括K和V，K唯一，V不唯一</p><ul><li><strong>HashMap：</strong>经典的Map，JAVA8之前使用数据+链表实现的，对于碰撞的情况使用链表存储，链表过长会影响查询速度，在JAVA8之后采用数组+链表+红黑树，当链表长度达到8之后就用红黑树处理碰撞情况，增加性能</li><li><strong>LinkedHashMap：</strong>HashMap + 双向链表，通过重写节点类，在原有的基础上增加before和after，增加了顺序存储的功能</li><li><strong>TreeMap：</strong>通过红黑树实现，可以对K进行排序</li><li><strong>ConcurrentHashMap：</strong>线程安全的高并发Map，不允许NULL，JAVA7采用分段锁提升性能，每一段数据单独枷锁，JAVA8采用CAS + synchronized，锁的粒度更小，空桶直接插入，有数据的锁住链表或者红黑树的两个头结点，如果两个线程没发生哈希冲突，就能完全并行</li></ul><h1 id="list" tabindex="-1">List <a class="header-anchor" href="#list" aria-label="Permalink to “List”">​</a></h1><h2 id="java-arraylist-的扩容机制是什么" tabindex="-1">Java ArrayList 的扩容机制是什么？ <a class="header-anchor" href="#java-arraylist-的扩容机制是什么" aria-label="Permalink to “Java ArrayList 的扩容机制是什么？”">​</a></h2><p>ArrayList 在每次添加数据的时候都会对其进行大小检查，如果发现装不下了，就会进行扩容，扩容的基数的1.5，也就是说，10长度的数组被扩容后会变成15，具体来说是：<code>newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)</code>，然后会将数据迁移到新数组，最后修改 elementData 的引用，指向新数组。</p><p>如果想要的大小超过了 int 的上限的时候，就通过 hugeCapacity 方法请求提供一个合法的大小，他的逻辑很简单，如果我们请求的大小是一个负数，就意味着之前的加法已经溢出了，这时候就抛出 OutOfMemoryError 表示溢出。接下来，他会返回两种值：</p><ul><li>一种是 <code>MAX_ARRAY_SIZE</code>，他是 <code>Integer.MAX_VALUE -8</code>的值，因为 ArrayList 的头结点根据不同的 JVM 可能存放不同的值，所以空出八个槽位用于数据存储</li><li>第二种是 <code>Integer.MAX_VALUE</code>他会在请求值大于 <code>MAX_ARRAY_SIZE</code>的情况下被返回，跟放手一搏差不多</li></ul><h2 id="arraylist-的-elementdata-为什么用-transient-修饰" tabindex="-1">ArrayList 的 elementData 为什么用 transient 修饰？ <a class="header-anchor" href="#arraylist-的-elementdata-为什么用-transient-修饰" aria-label="Permalink to “ArrayList 的 elementData 为什么用 transient 修饰？”">​</a></h2><p>为了防止序列化写入过多的空值，elementData 通常情况下实际长度大于使用的长度，默认序列化的时候会将这些空值写入，浪费空间。ArrayList 自己实现了 writeObject 和 readObject 方法，序列化的只有使用的部分，</p><h2 id="如果大量创建-new-arraylist-不往里面放东西-有什么危害-怎么解决的" tabindex="-1">如果大量创建 new ArrayList 不往里面放东西，有什么危害？怎么解决的？ <a class="header-anchor" href="#如果大量创建-new-arraylist-不往里面放东西-有什么危害-怎么解决的" aria-label="Permalink to “如果大量创建 new ArrayList 不往里面放东西，有什么危害？怎么解决的？”">​</a></h2><p>如果大量创建新的 ArrayList 不仅会占用大量的堆内存，而且对GC的回收负担也很大</p><p>解决方法：ArrayList 里提供了两个字段：<code>EMPTY_ELEMENTDATA``DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>，二者针对长度为0的创建操作和长度为10的默认创建操作进行优化，通过这两种方式创建的数组都指向这两个字段，用于减小内存开销和GC压力</p><h2 id="arraylist-能存多少个元素" tabindex="-1">ArrayList 能存多少个元素？ <a class="header-anchor" href="#arraylist-能存多少个元素" aria-label="Permalink to “ArrayList 能存多少个元素？”">​</a></h2><p>理论上的上限是 <code>Integer.MAX_VALUE</code>也就是大约21亿，但是实际上也受 JVM 限制，如果是64位的JVM，开了压缩指针每个引用也要占用8字节，差不多16G的内存就消耗在了引用上面，另外，数组的头部也有元数据开销，所以也受JVM的内存限制</p><h2 id="arrays-copyof-和-system-arraycopy-有什么区别" tabindex="-1">Arrays.copyOf 和 System.arraycopy 有什么区别？ <a class="header-anchor" href="#arrays-copyof-和-system-arraycopy-有什么区别" aria-label="Permalink to “Arrays.copyOf 和 System.arraycopy 有什么区别？”">​</a></h2><p>Arrays.copyOf 底层也是去调用 System.arraycopy 所以其实性能上没差别，但是 System.arraycopy 需要去指定复制到什么地方，Arrays.copyOf 在调用 System.arraycopy 之前就准备好了这个地方，不需要手动指定</p><h2 id="java-中-arraylist-和-linkedlist-有什么区别" tabindex="-1">Java 中 ArrayList 和 LinkedList 有什么区别？ <a class="header-anchor" href="#java-中-arraylist-和-linkedlist-有什么区别" aria-label="Permalink to “Java 中 ArrayList 和 LinkedList 有什么区别？”">​</a></h2><p>底层数据结构不同，ArrayList 底层是数组，LinkedList 底层是双向链表，这决定了他们的性能差异</p><ul><li>ArrayList 作为连续的数据结构，查找效率为 O(1)，直接定位下标就行，但是插入数据为 O(n)，因为需要对后面的元素进行移位</li><li>LinkedList 使用双向链表作为底层结构，查找效率为 O(n)，因为需要挨个遍历所有节点，但是对头尾节点的操作是 O(1)，改地址就行</li></ul><p>实际使用还是推荐使用 ArrayList，连续的数据结构缓存友好</p><p>其次，内存占用差距也不小，ArrayList 作为连续的数据结构，每个对象只占一个对象引用，四或八字节（开指针压缩就是四），而双向链表就不同了，他需要存放数据，前驱，后继，对象头，一个节点差不多是二十四字节，开销差了6倍</p><h2 id="arraylist-的中间插入真的很慢吗" tabindex="-1">ArrayList 的中间插入真的很慢吗？ <a class="header-anchor" href="#arraylist-的中间插入真的很慢吗" aria-label="Permalink to “ArrayList 的中间插入真的很慢吗？”">​</a></h2><p>我们了解到的，中间插入要将后面的数据后移，时间复杂度是 O(n)，但是，插入操作使用了 System.arraycopy 方法，是 native 方法，适合大批量内存整体移动，CPU对此类操作做了大量优化，其性能开销其实不是很大，远低于链表型数据结构的中间插入操作</p><h2 id="为什么-jdk-官方建议用-arraydeque-而不是-linkedlist-实现栈和队列" tabindex="-1">为什么 JDK 官方建议用 ArrayDeque 而不是 LinkedList 实现栈和队列？ <a class="header-anchor" href="#为什么-jdk-官方建议用-arraydeque-而不是-linkedlist-实现栈和队列" aria-label="Permalink to “为什么 JDK 官方建议用 ArrayDeque 而不是 LinkedList 实现栈和队列？”">​</a></h2><p>ArrayDeque 底层是循环数组，内存连续，CPU缓存友好，性能自然高，其次其不像链表，需要维护这么多的指针，开销也小，除非要去存 Null，不然 ArrayDeque 各方面都很优秀</p><h2 id="arraylist-和-vector-有什么区别" tabindex="-1">ArrayList 和 Vector 有什么区别？ <a class="header-anchor" href="#arraylist-和-vector-有什么区别" aria-label="Permalink to “ArrayList 和 Vector 有什么区别？”">​</a></h2><p>Vector 老古董了，JDK1的元老，线程安全，所有的方法都加了 synchronized，性能较低。JDK1.2加入了 ArrayList，不加锁，性能好，但是线程不安全，为了线程安全可以使用 synchronizedList 包裹 ArrayList 实现。</p><h2 id="java-中的-copyonwritearraylist-是什么" tabindex="-1">Java 中的 CopyOnWriteArrayList 是什么？ <a class="header-anchor" href="#java-中的-copyonwritearraylist-是什么" aria-label="Permalink to “Java 中的 CopyOnWriteArrayList 是什么？”">​</a></h2><p>CopyOnWriteArrayList 使用写时复制来保证线程安全，具体操作是在写的时候先对旧数组做一份拷贝，然后修改新数组，然后用新数组的引用取代旧数组的引用。读操作直接读取旧数组，实现读写分离</p><p>这样就导致写操作的开销比较大，因为每次写都得去复制整个数组，但是读操作非常快，因为没有加锁，适合读多写少的场景</p><p>值得一提的是，CopyOnWriteArrayList 的迭代器遍历是弱一致性的，因为迭代器遍历的是迭代器被创建的时候的数组的快照，和写操作隔离</p><h2 id="java-的-copyonwritearraylist-和-collections-synchronizedlist-有什么区别-分别有什么优缺点" tabindex="-1">Java 的 CopyOnWriteArrayList 和 Collections.synchronizedList 有什么区别？分别有什么优缺点？ <a class="header-anchor" href="#java-的-copyonwritearraylist-和-collections-synchronizedlist-有什么区别-分别有什么优缺点" aria-label="Permalink to “Java 的 CopyOnWriteArrayList 和 Collections.synchronizedList 有什么区别？分别有什么优缺点？”">​</a></h2><p>对于保证线程安全的方法不一样，synchronizedList 靠的是给所有方法加锁，这样并发性能低，CopyOnWriteArrayList 采用写时复制设计，读操作不加锁，写操作操作副本，并发程度高，另外 synchronizedList 在迭代器遍历场景下性能不如 CopyOnWriteArrayList 因为 CopyOnWriteArrayList 是使用快照遍历，而 synchronizedList 得加锁</p><h2 id="写时复制会不会有内存问题" tabindex="-1">写时复制会不会有内存问题？ <a class="header-anchor" href="#写时复制会不会有内存问题" aria-label="Permalink to “写时复制会不会有内存问题？”">​</a></h2><p>会的，如果写入操作十分频繁，就会同时存在多个数组的副本，严重情况可能内存爆掉，抛OOM</p><h2 id="copyonwritearraylist-能保证实时一致性吗" tabindex="-1">CopyOnWriteArrayList 能保证实时一致性吗？ <a class="header-anchor" href="#copyonwritearraylist-能保证实时一致性吗" aria-label="Permalink to “CopyOnWriteArrayList 能保证实时一致性吗？”">​</a></h2><p>不可以，因为 CopyOnWriteArrayList 采用写时复制技术，读操作本质上只是读取副本，在读操作进行的时候如果有写数据，是拿不到的，如果想要拿到最新数据，就得加锁，这样性能太低，属于是 CopyOnWriteArrayList 高读速的代价了</p><h2 id="copyonwritearraylist-在迭代的时候能修改吗" tabindex="-1">CopyOnWriteArrayList 在迭代的时候能修改吗？ <a class="header-anchor" href="#copyonwritearraylist-在迭代的时候能修改吗" aria-label="Permalink to “CopyOnWriteArrayList 在迭代的时候能修改吗？”">​</a></h2><p>可以的，迭代操作和修改操作不是操作同一个数组，迭代操作在迭代器创建的时候就拿到了数组的快照，是在这里进行的，修改操作是在新数组上进行的，互相独立，不会抛出 ConcurrentModificationException，但是迭代看到的数据可能是老旧的，当然，这在读多写少的情况下并不可怕</p><h2 id="copyonwritearraylist-的迭代器支持-remove-操作吗" tabindex="-1">CopyOnWriteArrayList 的迭代器支持 remove 操作吗？ <a class="header-anchor" href="#copyonwritearraylist-的迭代器支持-remove-操作吗" aria-label="Permalink to “CopyOnWriteArrayList 的迭代器支持 remove 操作吗？”">​</a></h2><p>并不支持，因为迭代器操作拿到的是是数据的快照，快照是只读的，强行操作只会抛 UnsupportedOperationException，删除只能调用 CopyOnWriteArrayList 自己的 remove 方法咯</p><h2 id="copyonwritearraylist-适合存几万条数据吗" tabindex="-1">CopyOnWriteArrayList 适合存几万条数据吗？ <a class="header-anchor" href="#copyonwritearraylist-适合存几万条数据吗" aria-label="Permalink to “CopyOnWriteArrayList 适合存几万条数据吗？”">​</a></h2><p>不适合，CopyOnWriteArrayList 采用写时复制技术，写的时候会 copy 整个数组，如果数据量非常大，每次写的内存开销也非常大，会频繁触发GC，上万的数据还是用别的吧</p><h2 id="synchronizedlist-和-vector-有什么区别" tabindex="-1">synchronizedList 和 Vector 有什么区别？ <a class="header-anchor" href="#synchronizedlist-和-vector-有什么区别" aria-label="Permalink to “synchronizedList 和 Vector 有什么区别？”">​</a></h2><p>性能上差不多，Vector 的每个方法都加上了 synchronized，synchronizedList 是在最外面套上了 synchronized，Vector 有点老旧，synchronizedList 可以包装任意实现了 List 接口的类，更加灵活</p><h1 id="map" tabindex="-1">Map <a class="header-anchor" href="#map" aria-label="Permalink to “Map”">​</a></h1><h2 id="说说-java-中-hashmap-的原理" tabindex="-1">说说 Java 中 HashMap 的原理 <a class="header-anchor" href="#说说-java-中-hashmap-的原理" aria-label="Permalink to “说说 Java 中 HashMap 的原理”">​</a></h2><ul><li>通过计算 Key 的 HashCode，然后用 <code>(table.length-1) &amp; hash</code> 计算出 Value 应该在数组的什么位置，然后存放</li><li>如果发生哈希碰撞，就把哈希值相同的 Value 通过链表串起来，在 JDK8 之后做了优化，对于长度大于八的链表，且数组长度大于64，使其进化成红黑树，以增加性能，在红黑树节点小于6时，退化成链表</li><li>如果数组的使用率超过了负载因子，就会进行扩容，数组大小翻倍，然后数据进行迁移，称之为 rehash，性能开销较大</li></ul><h2 id="java-中-hashmap-的扩容机制是怎样的" tabindex="-1">Java 中 HashMap 的扩容机制是怎样的？ <a class="header-anchor" href="#java-中-hashmap-的扩容机制是怎样的" aria-label="Permalink to “Java 中 HashMap 的扩容机制是怎样的？”">​</a></h2><ul><li>是否扩容主要有两个东西决定， 容量和负载因子，当使用率超过负载因子的时候，就会触发扩容，容量翻倍并且调整每个元素的位置，容量默认是16，负载因子默认是0.75</li><li>计算新位置的方法在1.8做了优化，数组的长度永远是二的N次方，根据公式：<code>(table.length-1) &amp; hash</code> 我们发现，在扩容前后，<code>(table.length-1)</code>只有高位多了个1，我们只需要检查<code>hash</code>的这一位是否是1就可以快速判断是否移动就可以</li><li>rehash 的性能开销大，为了平衡查询效率和 rehash 的性能开销，根据泊松分布分析，0.75是最优的解决方案</li><li>最好的方案就是指定初始的容量，大小为预计数据/0.75，需要注意，这个结果会靠近最近的2的幂次。1000为1024.</li></ul><h2 id="假设有一个-1g-大的-hashmap-此时用户请求过来刚好触发它的扩容-会怎样-让你改造下-hashmap-的实现该怎样优化" tabindex="-1">假设有一个 1G 大的 HashMap，此时用户请求过来刚好触发它的扩容，会怎样？让你改造下 HashMap 的实现该怎样优化？ <a class="header-anchor" href="#假设有一个-1g-大的-hashmap-此时用户请求过来刚好触发它的扩容-会怎样-让你改造下-hashmap-的实现该怎样优化" aria-label="Permalink to “假设有一个 1G 大的 HashMap，此时用户请求过来刚好触发它的扩容，会怎样？让你改造下 HashMap 的实现该怎样优化？”">​</a></h2><ul><li>1G 的 HashMap 显然很大，使用当前线程进行 rehash，就会进行阻塞，肯定不行</li><li>Redis是单线程的，如果他遇到这种大规模 Map 扩容，肯定也有很好的解决方案：渐进式rehash。 <ul><li>简而言之就是我们将原来一次性的扩容操作改成分批完成，在这个过程中，我们维护两个数组： <ul><li>原数组，包含未迁移的数据</li><li>新数组：存储扩容后的数据</li></ul></li><li>实现过程就是我们创建好新数组时候，只搬运一点数据，然后记录下当前搬运进度，当有插入，修改，查询的操作时，继续迁移部分数据，直到完成迁移</li><li>现在有两个数组，<code>get</code>操作会优先查找新数组，如果没有再去旧数组查找</li></ul></li><li>除了 Redis，ConcurrentHashMap 的多线程渐进扩容也很优秀 <ul><li>和 Redis 一样，ConcurrentHashMap 会创建另外一个二倍原数组大小的新数组用于存放迁移后的数据（nextTable），并且不会一次性迁移数据，其他线程可以参与这个迁移过程</li><li>ConcurrentHashMap 维护一个 transferIndex 用于记录当前迁移进度，从高位开始，逐步递减，每个线程都会抢占 transferIndex 的一段范围，执行迁移，如果某个桶的数据迁移完毕，就会将旧表中的引用替换为 ForwardingNode，指向 nextTable。</li><li>全部迁移完毕之后，nextTable 会替换原数组，nextTable 变为NULL，至此，扩容完成</li></ul></li></ul><h2 id="concurrenthashmap-扩容期间-如果一个线程正在查询数据-会被阻塞吗" tabindex="-1">ConcurrentHashMap 扩容期间，如果一个线程正在查询数据，会被阻塞吗? <a class="header-anchor" href="#concurrenthashmap-扩容期间-如果一个线程正在查询数据-会被阻塞吗" aria-label="Permalink to “ConcurrentHashMap 扩容期间，如果一个线程正在查询数据，会被阻塞吗?”">​</a></h2><p>很显然不会，ConcurrentHashMap 是异步进行扩容的，也就是说，扩容操作不会阻塞当前使用的线程，当前线程查询数据时，如果当前数据完成迁移，当前哈希桶就会读到 ForwardingNode，指向新表，就从新表读取数据了，不加锁，不阻塞</p><h2 id="如果扩容期间-多个线程同时要迁移同一个桶-会冲突吗" tabindex="-1">如果扩容期间，多个线程同时要迁移同一个桶，会冲突吗? <a class="header-anchor" href="#如果扩容期间-多个线程同时要迁移同一个桶-会冲突吗" aria-label="Permalink to “如果扩容期间，多个线程同时要迁移同一个桶，会冲突吗?”">​</a></h2><p>不会，根本不会出现多个线程枪一个桶的情况，因为 ConcurrentHashMap 通过 transferIndex 维护当前迁移进度，每个线程从这里领取桶范围，这个操作是原子性的，一个桶保证只会被一个线程迁移，不会冲突</p><h2 id="渐进式-rehash-会不会导致内存占用翻倍" tabindex="-1">渐进式 rehash 会不会导致内存占用翻倍? <a class="header-anchor" href="#渐进式-rehash-会不会导致内存占用翻倍" aria-label="Permalink to “渐进式 rehash 会不会导致内存占用翻倍?”">​</a></h2><p>会的，因为渐进式rehash 需要同时维护两个数组，需要消耗三倍的内存，这其实是一个空间换时间的解决方案，如果内存紧张，这个方案就不是这么适用了，可以考虑分片操作或者直接升级内存容量</p><h2 id="如果在扩容期间-频繁进行-put-操作-会不会导致扩容一直完不成" tabindex="-1">如果在扩容期间，频繁进行 put 操作，会不会导致扩容一直完不成? <a class="header-anchor" href="#如果在扩容期间-频繁进行-put-操作-会不会导致扩容一直完不成" aria-label="Permalink to “如果在扩容期间，频繁进行 put 操作，会不会导致扩容一直完不成?”">​</a></h2><p>并不会</p><ul><li>首先，put 操作会将数据放到新数组中， 不会出现哈希桶已经迁移完的情况下又进来新数据了</li><li>其次，put 操作会带动旧数据迁移，所以，put 的越快，迁移也越快</li><li>但是如果咔咔咔一直 put，原数组还没扩容完成，新数组就满了，那就是另外一回事了，我们要重新规划容量了</li></ul><h2 id="扩容的时候-链表和红黑树的处理方式一样吗" tabindex="-1">扩容的时候，链表和红黑树的处理方式一样吗？ <a class="header-anchor" href="#扩容的时候-链表和红黑树的处理方式一样吗" aria-label="Permalink to “扩容的时候，链表和红黑树的处理方式一样吗？”">​</a></h2><p>不一样</p><ul><li>链表在被迁移的时候会通过 HashCode的高位情况，分裂成两个链表，高位为1的移动到原下标+旧数组长度的位置，高位为0的保持不变</li><li>红黑树也是进行这样的操作，分成两个红黑树，但是分完要进行检查，如果节点小于6个，就要进行退化</li></ul><h2 id="hashmap-扩容时线程安全吗" tabindex="-1">HashMap 扩容时线程安全吗？ <a class="header-anchor" href="#hashmap-扩容时线程安全吗" aria-label="Permalink to “HashMap 扩容时线程安全吗？”">​</a></h2><p>不安全，如果两个线程同时进行扩容操作，就会导致链表成环，get 的时候就会一直循环，爆炸了，1.8改用尾插法解决了这个问题，但是put 的时候还是会丢数据，数据被覆盖，所以，使用 ConcurrentHashMap 更加安全</p><h2 id="jdk-8-改成尾插法就完全线程安全了吗" tabindex="-1">JDK 8 改成尾插法就完全线程安全了吗？ <a class="header-anchor" href="#jdk-8-改成尾插法就完全线程安全了吗" aria-label="Permalink to “JDK 8 改成尾插法就完全线程安全了吗？”">​</a></h2><p>其实也不安全，尾插法解决的是扩容时形成环的问题，但是并发场景下put还是会丢数据</p><h2 id="能不能让-hashmap-不扩容" tabindex="-1">能不能让 HashMap 不扩容？ <a class="header-anchor" href="#能不能让-hashmap-不扩容" aria-label="Permalink to “能不能让 HashMap 不扩容？”">​</a></h2><p>当然可以，直接让负载因子非常大，就不会扩容，但是这种方法显然不合适，以为内如果一直不扩容，就会一直发生碰撞，单个桶下的数据急剧增多，查找效率急剧下降，即使有红黑树兜底，频繁树化效率也是惨不忍睹，还是应该预估一下数据的数量，设置好初始容量</p><h2 id="java-中的-hashcode-和-equals-方法之间有什么关系" tabindex="-1">Java 中的 hashCode 和 equals 方法之间有什么关系？ <a class="header-anchor" href="#java-中的-hashcode-和-equals-方法之间有什么关系" aria-label="Permalink to “Java 中的 hashCode 和 equals 方法之间有什么关系？”">​</a></h2><p>equals 相等的对象，hashCode 必须相等；hashCode 相等的对象，equals 不一定相等</p><p>这个有什么用呢，如果我们需要更改一个对象的 equals 方法，同时这个对象也要被放到 HashMap 或者 HashSet中，那么也要重写 hashCode 方法，因为 HashMap 和 HashSet 在判断是否相等的时候会优先调用 hashCode 方法，如果没有重写 hashCode 方法，这一关过不去，其也不会去调用 equals 方法，集合的单一性就不能保证了</p><h2 id="两个对象-hashcode-相同但-equals-不相等-这种情况叫什么-会影响-hashmap-性能吗" tabindex="-1">两个对象 hashCode 相同但 equals 不相等，这种情况叫什么？会影响 HashMap 性能吗？ <a class="header-anchor" href="#两个对象-hashcode-相同但-equals-不相等-这种情况叫什么-会影响-hashmap-性能吗" aria-label="Permalink to “两个对象 hashCode 相同但 equals 不相等，这种情况叫什么？会影响 HashMap 性能吗？”">​</a></h2><p>典型的哈希冲突，如果发生这种情况，HashMap 会将这两个对象以链表的形式组织到一个槽里面，如果之后还发生了碰撞，就加长链表，JDK8 之后，如果链表长度大于8就使用红黑树代替链表，优化查询速度</p><h2 id="string-类的-hashcode-是怎么算的-为什么这么设计" tabindex="-1">String 类的 hashCode 是怎么算的？为什么这么设计？ <a class="header-anchor" href="#string-类的-hashcode-是怎么算的-为什么这么设计" aria-label="Permalink to “String 类的 hashCode 是怎么算的？为什么这么设计？”">​</a></h2><p>Java 中 String 类的 hashCode 计算方式是一个基于 31 的多项式累加算法，具体来说：h = 31 * h + c，计算完毕之后就进行缓存，因为String不可变，之后直接返回就行。选择 31 作为乘数是因为他是奇质数，计算出来的哈希值比较均匀，而且31正好是32-1，可以被JVM优化为位移和减法，计算效率更高</p><h2 id="hashmap-的-key-用可变对象有什么风险" tabindex="-1">HashMap 的 key 用可变对象有什么风险？ <a class="header-anchor" href="#hashmap-的-key-用可变对象有什么风险" aria-label="Permalink to “HashMap 的 key 用可变对象有什么风险？”">​</a></h2><p>很简单，如果使用可变对象作为K的话，一旦这个我们更改这个Key，HashCode 也会不一样，我们拿着新的 HashCode 去找，肯定找不到，原来的数据也删不掉，就这样造成了内存泄漏，极其不安全</p><h2 id="重写-equals-不重写-hashcode-除了集合出问题-还有什么影响" tabindex="-1">重写 equals 不重写 hashCode，除了集合出问题，还有什么影响？ <a class="header-anchor" href="#重写-equals-不重写-hashcode-除了集合出问题-还有什么影响" aria-label="Permalink to “重写 equals 不重写 hashCode，除了集合出问题，还有什么影响？”">​</a></h2><p>基本不会有问题，但是保不齐那天突然要放到里面，还有就是不是我们想放到里面，有些框架需要将具体对象放到集合中进行维护，而那时候又忘了重写，给自己埋雷了属于是</p><h2 id="为什么-jdk-1-8-对-hashmap-进行了红黑树的改动" tabindex="-1">为什么 JDK 1.8 对 HashMap 进行了红黑树的改动？ <a class="header-anchor" href="#为什么-jdk-1-8-对-hashmap-进行了红黑树的改动" aria-label="Permalink to “为什么 JDK 1.8 对 HashMap 进行了红黑树的改动？”">​</a></h2><ul><li>在1.8之前，对于哈希碰撞的处理一般是将这些发生碰撞的对象组织到一条链表进行管理，查询的时候挨个进行比对，效率低下，如果有人故意存入大量互相碰撞的对象，然后查询，就会直接卡死，当当，这就是哈希碰撞攻击</li><li>1.8采用树化的机制来应对这种问题，简单来说就是当链表的长度大于8且数组长度大于64的时候，就进行树化操作，链表转化为红黑树，查询效率从 O(n) 变为 O(log n)。如果节点数目变为6以下，再次退化成链表</li><li>使用8和6为界限判断是为了防止这些发生碰撞的数据从链表和红黑树之间反复横跳带来的性能开销</li></ul><h2 id="什么是-hash-碰撞-怎么解决哈希碰撞" tabindex="-1">什么是 Hash 碰撞？怎么解决哈希碰撞？ <a class="header-anchor" href="#什么是-hash-碰撞-怎么解决哈希碰撞" aria-label="Permalink to “什么是 Hash 碰撞？怎么解决哈希碰撞？”">​</a></h2><p>Hash 碰撞就是两个对象经过 Hash 函数计算之后，得到了相同的哈希值，这种情况几乎不可避免，如果我们的哈希数组有16大小，而我们有17个数据，那就一定会发生碰撞</p><p>主要解决办法：</p><ul><li><p>拉链法：将发生碰撞的两个对象通过链表组织起来，查询的时候遍历整个链表，相同就输出，插入的时候插到尾部，优点就是方案简单，内存利用率高，缺点就是链表查询速度慢，容易被攻击，可以通过树化链表解决</p></li><li><p>开放寻址法：我们不使用额外的结构来组织发生碰撞的对象，而是让碰撞的对象在数组中以一定的方式自己寻找空位，常用探测方式：</p><ul><li>线性探测：如果当前位置不是空位，就往下+1的位置找，如果还不是就接着找</li><li>二次探测：如果当前位置不是空位，就往当前位置 + 1^2找，如果没有就是 + 2^2找</li></ul><p>很显然，查找的时候就也得按照这种方式查找，删除操作就显得麻烦，因为如果单纯的删除元素，会导致后面的元素被丢失，所以要打标记，逻辑上来说比较麻烦，而且容易堆积，性能低下</p></li><li><p>再哈希法：如果计算发生冲突，那我们换一个哈希值再算一次就好了，一直到找到空位 很明显，这种方式计算方面开销比较大，而且我们需要准备好几个优质的哈希函数，比较麻烦</p></li></ul><h2 id="为什么-hashmap-选择拉链法而不是开放寻址法" tabindex="-1">为什么 HashMap 选择拉链法而不是开放寻址法？ <a class="header-anchor" href="#为什么-hashmap-选择拉链法而不是开放寻址法" aria-label="Permalink to “为什么 HashMap 选择拉链法而不是开放寻址法？”">​</a></h2><p>主要是为删除效率考虑，HashMap 需要支持频繁的增删改查，如果使用开放寻址法来说，删除的开销会大得多</p><p>其次就是 HashMap 的负载因子是 0.75，这个负载因子如果使用开放寻址法，性能就会变的低下</p><h2 id="java-中的-weakhashmap-是什么" tabindex="-1">Java 中的 WeakHashMap 是什么 ？ <a class="header-anchor" href="#java-中的-weakhashmap-是什么" aria-label="Permalink to “Java 中的 WeakHashMap 是什么 ？”">​</a></h2><p>WeakHashMap 是特殊的 Map 实现，他的键使用弱引用包装，这意味着如果外部没有强引用，他就会被清理掉，随后，WeakHashMap 会清理掉这个键值对。我们可以通过这个特性将一些对内存敏感的缓存放到这里，这样当程序不再使用这个值的时候，他会被清理，防止内存泄露</p><h2 id="weakhashmap-的-value-是强引用还是弱引用-会不会内存泄漏" tabindex="-1">WeakHashMap 的 value 是强引用还是弱引用？会不会内存泄漏？ <a class="header-anchor" href="#weakhashmap-的-value-是强引用还是弱引用-会不会内存泄漏" aria-label="Permalink to “WeakHashMap 的 value 是强引用还是弱引用？会不会内存泄漏？”">​</a></h2><p>Value 是强引用，但是 WeakHashMap 在每次被操作的时候，都会触发 <code>expungeStaleEntries()</code>方法，清理掉失效的entity，也就是 key被回收的导致的失效，但是如果只是往 WeakHashMap 存入东西后就不操作了，Key 被 GC 回收后，Value 确实会发生泄露</p><h2 id="weakhashmap-是线程安全的吗-多线程环境下怎么用" tabindex="-1">WeakHashMap 是线程安全的吗？多线程环境下怎么用？ <a class="header-anchor" href="#weakhashmap-是线程安全的吗-多线程环境下怎么用" aria-label="Permalink to “WeakHashMap 是线程安全的吗？多线程环境下怎么用？”">​</a></h2><p>不安全，多线程可以用 Collections.synchronizedMap 包一层，也可以换成 Guava 的 Cache 进行缓存的实现，本身也支持并发，ConcurrentHashMap 包不了弱引用，不能作为 WeakHashMap 的替代品</p><h2 id="weakhashmap-的-value-会被自动回收吗" tabindex="-1">WeakHashMap 的 value 会被自动回收吗？ <a class="header-anchor" href="#weakhashmap-的-value-会被自动回收吗" aria-label="Permalink to “WeakHashMap 的 value 会被自动回收吗？”">​</a></h2><p>不会，WeekHashMap 的 Value 是强引用的，Key 才是弱引用，当 Key 被回收之后，Value 成了孤儿，然后当 WeakHashMap 被操作的时候，会触发 <code>expungeStaleEntries()</code>方法，这个时候，成为孤儿的 Value 才会被回收，如果想要 Value 也被主动回收，可以用 WeakReference 包装 Value。</p><h2 id="hash-洪水攻击是怎么回事-怎么防范" tabindex="-1">Hash 洪水攻击是怎么回事？怎么防范？ <a class="header-anchor" href="#hash-洪水攻击是怎么回事-怎么防范" aria-label="Permalink to “Hash 洪水攻击是怎么回事？怎么防范？”">​</a></h2><p>攻击者通过向哈希表中存入大量哈希值相同的不同对象，导致其都挂载到一个桶上，如果使用拉链法，查询效率就会从 O1 退化到 On，JDK8 优化了这一问题，链表在长度达到8的时候会向红黑树转化，使得查询效率优化到 O(log n)，</p><h2 id="负载因子和碰撞概率有什么关系" tabindex="-1">负载因子和碰撞概率有什么关系？ <a class="header-anchor" href="#负载因子和碰撞概率有什么关系" aria-label="Permalink to “负载因子和碰撞概率有什么关系？”">​</a></h2><p>负载因子等于 元素个数/数组长度，也就是说，当负载因子越小，数组里面的东西越少，发生碰撞的概率越小，相应的，要更加频繁的扩容，空间利用率低，但是查询速度快，如果负载因子大，扩容速度慢，空间利用率高，但是查询速度会放慢</p><h2 id="实际项目中你会去改这个负载因子吗-什么情况下会改" tabindex="-1">实际项目中你会去改这个负载因子吗？什么情况下会改？ <a class="header-anchor" href="#实际项目中你会去改这个负载因子吗-什么情况下会改" aria-label="Permalink to “实际项目中你会去改这个负载因子吗？什么情况下会改？”">​</a></h2><p>并不会改，这玩意是经过数学验证的，是一个很好的平衡点，适用于大部分场景，当然，如果内存很紧张，比如嵌入式设备，会调整比较高，如果对查询速度有要求，可以调的比较低</p><h2 id="concurrenthashmap-的负载因子也是-0-75-吗-能改吗" tabindex="-1">ConcurrentHashMap 的负载因子也是 0.75 吗？能改吗？ <a class="header-anchor" href="#concurrenthashmap-的负载因子也是-0-75-吗-能改吗" aria-label="Permalink to “ConcurrentHashMap 的负载因子也是 0.75 吗？能改吗？”">​</a></h2><p>是的，而且不能改，这玩意是写死的，官方并没有为了这个去增加一个API，当然可以通过反射来更改，但是也不推荐</p><h2 id="简单解释下为什么用泊松分布来分析树化阈值吗" tabindex="-1">简单解释下为什么用泊松分布来分析树化阈值吗？ <a class="header-anchor" href="#简单解释下为什么用泊松分布来分析树化阈值吗" aria-label="Permalink to “简单解释下为什么用泊松分布来分析树化阈值吗？”">​</a></h2><p>当负载因子为0.75 的时候，λ 大约是 0.5，同时有八个元素在一起的概率变的相当低，所以这是有数学依据的</p><h2 id="java-中的-treemap-是什么" tabindex="-1">Java 中的 TreeMap 是什么？ <a class="header-anchor" href="#java-中的-treemap-是什么" aria-label="Permalink to “Java 中的 TreeMap 是什么？”">​</a></h2><p>TreeMap的底层是红黑树，先天具有排序功能，也可以自定义排序规则</p><h2 id="java-中的红黑树是什么" tabindex="-1">Java 中的红黑树是什么？ <a class="header-anchor" href="#java-中的红黑树是什么" aria-label="Permalink to “Java 中的红黑树是什么？”">​</a></h2><p>红黑树就是一个二叉树，所以查找也是二叉搜索数查找，比当前节点小就往左走，大就往右走</p><h2 id="treemap-和-treeset-是什么关系" tabindex="-1">TreeMap 和 TreeSet 是什么关系？ <a class="header-anchor" href="#treemap-和-treeset-是什么关系" aria-label="Permalink to “TreeMap 和 TreeSet 是什么关系？”">​</a></h2><p>其实 TreeSet 就是对 TreeMap 的复用，其中 Key 就是实际的值，Value 就是一 Object 站位，</p><h2 id="为什么红黑树比-avl-树更常用" tabindex="-1">为什么红黑树比 AVL 树更常用？ <a class="header-anchor" href="#为什么红黑树比-avl-树更常用" aria-label="Permalink to “为什么红黑树比 AVL 树更常用？”">​</a></h2><p>红黑树的平衡条件是左右子树的高度差不超过两倍，AVL树的平衡条件是高度差不超过1，显然AVL树的平衡条件更加严格，导致下面两种情况：</p><ul><li>红黑树由于平衡条件宽松，旋转次数少，树高高，导致插入，删除效率高，查找效率低</li><li>AVL树由于平衡条件严格，旋转次数多，树高低，导致查询效率高，插入，删除效率低</li></ul><p>对于工程上写多读少的情况，属于红黑树的优势区间，AVL树来说，更加适用于数据库的情景</p><h2 id="treemap-能保证线程安全吗-怎么在多线程环境下使用" tabindex="-1">TreeMap 能保证线程安全吗？怎么在多线程环境下使用？ <a class="header-anchor" href="#treemap-能保证线程安全吗-怎么在多线程环境下使用" aria-label="Permalink to “TreeMap 能保证线程安全吗？怎么在多线程环境下使用？”">​</a></h2><p>不能保证线程安全，可以使用 Collections.synchronizedSortedMap 包一层，或者使用 ConcurrentSkipListMap，ConcurrentSkipListMap底层是跳表，比加锁的红黑树性能优越</p><h2 id="红黑树的旋转操作是什么意思-为什么需要旋转" tabindex="-1">红黑树的旋转操作是什么意思？为什么需要旋转？ <a class="header-anchor" href="#红黑树的旋转操作是什么意思-为什么需要旋转" aria-label="Permalink to “红黑树的旋转操作是什么意思？为什么需要旋转？”">​</a></h2><p>红黑树的旋转操作是在平衡被打破的时候需要进行的调整操作，分为左旋和右旋，左旋就是让自己的右节点作为自己的父节点，自己成为右节点的左节点，这样不影响二叉搜索树的性质，只改变高度，目的是维持平衡性</p><h2 id="concurrenthashmap-也有红黑树吗-实现上有什么不同" tabindex="-1">ConcurrentHashMap 也有红黑树吗？实现上有什么不同？ <a class="header-anchor" href="#concurrenthashmap-也有红黑树吗-实现上有什么不同" aria-label="Permalink to “ConcurrentHashMap 也有红黑树吗？实现上有什么不同？”">​</a></h2><p>是的是的，但是区别就是 ConcurrentHashMap 在树化发生的时候给头结点加锁，保证线程安全，</p><p>另外 HashMap 中哈希桶的头结点就是红黑树的根节点，但是在并发场景下操作时非常危险的，因为红黑树会旋转，所以加锁并不靠谱，头结点可能会旋转，导致锁失效，ConcurrentHashMap 维护了一个 TreeBin 节点，其实就是对红黑树的根节点做了封装，加锁就是加的这个节点的锁，更加安全</p><h2 id="hashmap-的-key-可以用-null-吗" tabindex="-1">HashMap 的 key 可以用 null 吗？ <a class="header-anchor" href="#hashmap-的-key-可以用-null-吗" aria-label="Permalink to “HashMap 的 key 可以用 null 吗？”">​</a></h2><p>可以的，null 的 HashCode 是0，直接放在第一个桶里面，但是并发场景下，使用 ConcurrentHashMap 的话就不支持了，因为 null 无法保证是值，而不是空</p><h2 id="使用-hashmap-时-有哪些提升性能的技巧" tabindex="-1">使用 HashMap 时，有哪些提升性能的技巧？ <a class="header-anchor" href="#使用-hashmap-时-有哪些提升性能的技巧" aria-label="Permalink to “使用 HashMap 时，有哪些提升性能的技巧？”">​</a></h2><p>首先影响 HashMap 的主要因素就是发生哈希碰撞引起的查找效率下降和发生扩容时的 rehash 操作。着手优化这两点就行</p><ul><li>负载因子不乱调，0.75 是官方精心测试的值，在这个值下，发生碰撞的概率比较小，而且空间利用率高</li><li>Key 的 HashCode 方法必须使其均匀分布，防止堆积导致查询效率降低</li><li>预估初始容量，防止频繁扩容，rehash 的开销不小，频繁的进行扩容操作会吃掉大部分资源，所以根据这个map要存放多少值设置初始容量也很有效</li></ul><p>其次，在遍历场景的时候，使用 KeySet 拿到所有的 key，然后再靠 key 拿到所有的 value 是非常傻的，可以直接使用 entrySet 来获取 HashMap 中的 Entity 对象，这样可以避免一次的 Hash 开销</p><h2 id="hashmap-给太大会有什么问题" tabindex="-1">HashMap 给太大会有什么问题？ <a class="header-anchor" href="#hashmap-给太大会有什么问题" aria-label="Permalink to “HashMap 给太大会有什么问题？”">​</a></h2><p>第一就是会造成内存的浪费，给一万实际存10，内存直接就浪费了，其次就是缓存不友好，命中率低。实际中还是估算应该用多少然后给多少。</p><h2 id="concurrenthashmap-和-collections-synchronizedmap-有什么区别" tabindex="-1">ConcurrentHashMap 和 Collections.synchronizedMap 有什么区别？ <a class="header-anchor" href="#concurrenthashmap-和-collections-synchronizedmap-有什么区别" aria-label="Permalink to “ConcurrentHashMap 和 Collections.synchronizedMap 有什么区别？”">​</a></h2><p>synchronizedMap 的实现原理是给所有的操作都加了锁，任何操作都是互斥的，安全得很，同时性能也低得很，ConcurrentHashMap 在 JDK7 之前的解决方案就是给数据进行分段加锁，细化锁的粒度，性能提升明显，JDK8 又做了优化，使用 CAS + synchronized 锁住单个桶，粒度更小，并发场景下效率比 synchronizedMap 高好几倍</p><h2 id="为什么-hashmap-的容量必须是-2-的幂次" tabindex="-1">为什么 HashMap 的容量必须是 2 的幂次？ <a class="header-anchor" href="#为什么-hashmap-的容量必须是-2-的幂次" aria-label="Permalink to “为什么 HashMap 的容量必须是 2 的幂次？”">​</a></h2><p>因为 HashCode 的计算方式是 <code>(size - 1)&amp; hash</code>如果使用二的幂次方，size - 1 全是连续的1，等价于取模，而且容量是二的幂次方，扩容可以迅速判断是否移动，不用重新计算哈希值</p><p>HashMap 在被创建的时候，容量总是2的幂次方，也就是说传入1000会变成1024</p><h2 id="位运算比取模快多少-有没有具体的性能数据" tabindex="-1">位运算比取模快多少？有没有具体的性能数据？ <a class="header-anchor" href="#位运算比取模快多少-有没有具体的性能数据" aria-label="Permalink to “位运算比取模快多少？有没有具体的性能数据？”">​</a></h2><p>x86 的系统架构下，除法需要 20 到 40 个时钟周期，而位运算只需要一个就可以了，差的不是一点半点，其实从操作上来说感知其实差距不大，但是 HashMap 的存取操作十分频繁，差距就体现出来了，对于一些高性能框架，使用位运算优化是很常见的操作</p><h2 id="concurrenthashmap-和-hashtable-的区别是什么" tabindex="-1">ConcurrentHashMap 和 Hashtable 的区别是什么？ <a class="header-anchor" href="#concurrenthashmap-和-hashtable-的区别是什么" aria-label="Permalink to “ConcurrentHashMap 和 Hashtable 的区别是什么？”">​</a></h2><p>Hashtable 和 ConcurrentHashMap 都是线程安全的 map，但是实现方式不同</p><ul><li>Hashtable 非常暴力，在整个 map 上加了一个大锁，所以并发性能很差</li><li>ConcurrentHashMap 将整个哈希桶分成了 16 个部分，每个单独加锁，理论上可以有16 个线程去同时访问，在JDK8之后，又做了优化，现在锁的粒度是每个桶，并发效率更高</li></ul><p>另外 Hashtable 和 ConcurrentHashMap 都不能存储 null，都是因为不能保证多线程情况下放的到底是 null 还是确实不存在</p><h2 id="说说concurrenthashmap-的-cas-synchronized-机制" tabindex="-1">说说ConcurrentHashMap 的 CAS + synchronized 机制？ <a class="header-anchor" href="#说说concurrenthashmap-的-cas-synchronized-机制" aria-label="Permalink to “说说ConcurrentHashMap 的 CAS + synchronized 机制？”">​</a></h2><p>CAS + synchronized 机制是针对不同情况下的哈希桶的操作。</p><ul><li>CAS 是针对空的哈希桶的操作，使用 CAS 直接插入新节点，不用加锁</li><li>synchronized 是针对发生了哈希碰撞的桶采取的情况，他会将哈希桶的头节点加锁，也就是 Node 或者 TreeBin，来保证线程安全</li></ul><h2 id="说说-concurrenthashmap-对-size-方法的特殊处理" tabindex="-1">说说 ConcurrentHashMap 对 size 方法的特殊处理？ <a class="header-anchor" href="#说说-concurrenthashmap-对-size-方法的特殊处理" aria-label="Permalink to “说说 ConcurrentHashMap 对 size 方法的特殊处理？”">​</a></h2><p>对于并发场景下使用的 ConcurrentHashMap 来说，维护一个全局的，单一的 size 是不现实的，不可能所有 put 的线程都去做 size 的竞争</p><p>ConcurrentHashMap 创建了两个地方用于存储：</p><ul><li>baseCount：作为基础计数，在竞争不激烈的情况下，BaseCount 会去更新，</li><li>counterCells 是一个数组，当 baseCount 被使用的时候，其他线程就去这个数组，随机的找一块地方更新一下就完了</li></ul><p>然后计数的时候就将他们加起来，这就是最后得到的 size</p><p>这样做肯定不精确，因为可能会发生前面的数组刚被遍历完，又被更改了的情况，导致得到的结果是近似值，但是问题不大啦，对于 ConcurrentHashMap 来说，最终一致性已经很不错了</p><h2 id="java-中-concurrenthashmap-1-7-和-1-8-之间有哪些区别" tabindex="-1">Java 中 ConcurrentHashMap 1.7 和 1.8 之间有哪些区别？ <a class="header-anchor" href="#java-中-concurrenthashmap-1-7-和-1-8-之间有哪些区别" aria-label="Permalink to “Java 中 ConcurrentHashMap 1.7 和 1.8 之间有哪些区别？”">​</a></h2><ul><li>锁的粒度：1.7使用的是多个 Segment 数组，他们共同组成 ConcurrentHashMap，每个 Segment 数组单独加锁，以此提高并发效率。1.8 使用整个数组来作为 ConcurrentHashMap，每个哈希桶使用 CAS + synchronized 提升并发效率</li><li>扩容：1.7 之前因为使用的是分段管理，所以每个 segment 数组单独维护自己的扩容，每个 segment 都有自己的负载因子，扩容的时候单个扩容，不影响其他的 segment 工作。1.8 使用整体数组，当需要扩容的时候，整体开始扩容，过程通过 CAS 确保线程安全，而且引用渐进式扩容，提升了扩容效率，而且来访问的其他线程发现正在扩容之后，也会去协助扩容</li><li>size 的计算区别：1.7 使用分段数组，计算总体 size 的时候，有一个小巧思：他会先进行不加锁的计算所有 segment 的 size 的 sum。如果三次都一样，说明结果是对的，数量没有变化，就直接返回，如果数量有变化，就说明当前有线程去操作数组，就会将整体的数组进行加锁，然后去计算。1.8 之后采用的设计是维护了两个变量，一个是 long 类型的 BaseCount，另外一个就是 CounterCell 数组，CounterCell 里面只有一个 long 类型的 Value。使用 Contended 来防止伪共享。当发生增删的时候，首先去操作 BaseCount，如果 BaseCount 正在被使用，转而去 CounterCell 数组中随便找个地方记录一下更改，之所以重新创建一个 CounterCell 对象，是为了防止连续的数组带来的伪共享。计算 size 的时候，就把他们的加起来就行了</li></ul><h1 id="set" tabindex="-1">Set <a class="header-anchor" href="#set" aria-label="Permalink to “Set”">​</a></h1></div></div></main><footer class="VPDocFooter" data-v-7011f0d8 data-v-e257564d><!--[--><!--]--><div class="edit-info" data-v-e257564d><!----><div class="last-updated" data-v-e257564d><p class="VPLastUpdated" data-v-e257564d data-v-3c637f39>最后更新于: <time datetime="2026-02-14T18:18:25.000Z" data-v-3c637f39></time></p></div></div><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-e257564d><span class="visually-hidden" id="doc-footer-aria-label" data-v-e257564d>Pager</span><div class="pager" data-v-e257564d><a class="VPLink link pager-link prev" href="/pages/Articles/InterviewNotes/Java/JavaBasic/JavaBasic.html" data-v-e257564d><!--[--><span class="desc" data-v-e257564d>Previous page</span><span class="title" data-v-e257564d>Java 基础</span><!--]--></a></div><div class="pager" data-v-e257564d><a class="VPLink link pager-link next" href="/pages/Articles/InterviewNotes/Java/JavaConcurrency/JavaConcurrency.html" data-v-e257564d><!--[--><span class="desc" data-v-e257564d>Next page</span><span class="title" data-v-e257564d>Java 并发编程</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter has-sidebar" data-v-1df9f90f data-v-c3855bb3><div class="container" data-v-c3855bb3><p class="message" data-v-c3855bb3>Contact me: 1943284256@qq.com</p><p class="copyright" data-v-c3855bb3>©2026 XIA All rights reserved.</p></div></footer><!--[--><div><div class="visitor-counter" data-v-904f8600><span id="busuanzi_container_site_pv" style="display:none;" data-v-904f8600> 👀 你是第 <span id="busuanzi_value_site_pv" data-v-904f8600></span> 位来看的人！ </span></div><div class="floating-toolbar" data-v-8b5f1457><button class="main-button" aria-label="工具栏" data-v-8b5f1457><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-v-8b5f1457><circle cx="12" cy="12" r="1" data-v-8b5f1457></circle><circle cx="12" cy="5" r="1" data-v-8b5f1457></circle><circle cx="12" cy="19" r="1" data-v-8b5f1457></circle></svg></button><!----><!----></div><!----></div><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"index.md\":\"Dj2PjC6I\",\"pages_articles_designpattern_behavioralpattern_chainofresponsibilitypattern_chainofresponsibilitypattern.md\":\"DqQW8hF9\",\"pages_articles_designpattern_creationalpattern_builderpattern_builderpattern.md\":\"BKg-Nvms\",\"pages_articles_designpattern_creationalpattern_factorypattern_factorypattern.md\":\"CWszOkbx\",\"pages_articles_designpattern_creationalpattern_prototypepattern_prototypepattern.md\":\"C5ZEoO9L\",\"pages_articles_designpattern_creationalpattern_singletonpattern_singletonpattern.md\":\"ry3qNgHn\",\"pages_articles_designpattern_designpattern.md\":\"Dktijwbe\",\"pages_articles_designpattern_structuralpattern_adapterpattern_adapterpattern.md\":\"W_Pdo4bl\",\"pages_articles_designpattern_structuralpattern_bridgepattern_bridgepattern.md\":\"D8-eSYZ_\",\"pages_articles_designpattern_structuralpattern_compositepattern_compositepattern.md\":\"HP6CmiG_\",\"pages_articles_designpattern_structuralpattern_decoratorpattern_decoratorpattern.md\":\"kk-orexC\",\"pages_articles_designpattern_structuralpattern_facadepattern_facadepattern.md\":\"Bm-dISOM\",\"pages_articles_designpattern_structuralpattern_filterpattern_filterpattern.md\":\"MuK0c3_1\",\"pages_articles_designpattern_structuralpattern_flyweightpattern_flyweightpattern.md\":\"B3MKIHnE\",\"pages_articles_designpattern_structuralpattern_proxypattern_proxypattern.md\":\"wc9_5bIS\",\"pages_articles_gitcommitconventions_gitcommitconventions.md\":\"BayM5ncT\",\"pages_articles_interviewnotes_index.md\":\"C4LCJGVF\",\"pages_articles_interviewnotes_java_javabasic_javabasic.md\":\"C_T6z1QE\",\"pages_articles_interviewnotes_java_javacollection_javacollection.md\":\"B8DJYqxa\",\"pages_articles_interviewnotes_java_javaconcurrency_javaconcurrency.md\":\"y1HcxRNe\",\"pages_articles_interviewnotes_java_jvm_jvm.md\":\"eNWuB9yY\",\"pages_articles_interviewnotes_redis_redisnotes.md\":\"CdejPlb9\",\"pages_documents_springnotes_index.md\":\"DqEzPBdP\",\"pages_documents_springnotes_springmvc_responsebodyemitter.md\":\"Ccq3HeBi\",\"pages_documents_sql_01：基础指令.md\":\"NEFPhepc\",\"pages_documents_sql_02：函数.md\":\"5vrC7a-E\",\"pages_documents_sql_03：约束.md\":\"xn-XPY9M\",\"pages_documents_sql_04：多表查询.md\":\"DJNySq5V\",\"pages_documents_sql_05：事务.md\":\"-cShP97H\",\"pages_documents_sql_06：存储引擎.md\":\"DmMYHJuR\",\"pages_documents_sql_07：索引.md\":\"D6oTmzwx\",\"pages_documents_sql_08：性能分析.md\":\"BxZnqMwM\",\"pages_documents_sql_09：sql优化.md\":\"DZLrx482\",\"pages_documents_sql_10：视图.md\":\"CrrXlBN_\",\"pages_documents_sql_11：存储.md\":\"DZQPMOTE\",\"pages_documents_sql_12：触发器.md\":\"bSFptzvL\",\"pages_documents_sql_13：锁.md\":\"CS_yIPli\",\"pages_documents_sql_14：innodb.md\":\"BMFniToV\",\"pages_documents_sql_15：mysql管理.md\":\"CsykAglu\",\"pages_documents_sql_16：日志.md\":\"wyKOXsfF\",\"pages_documents_sql_17：主从复制.md\":\"BtaR-Bv7\",\"pages_documents_sql_18：分库分表.md\":\"wDXTAqRw\",\"pages_documents_sql_index.md\":\"DUtNWJ6H\",\"pages_groceries_magaopythonnotess1.md\":\"plUxu4mR\",\"pages_music_index.md\":\"9fzViA9q\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"XIA\",\"description\":\"探索……沉淀……成长！分享技术学习笔记和实践经验\",\"base\":\"/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"logo\":\"/logo.svg\",\"search\":{\"provider\":\"local\"},\"nav\":[{\"text\":\"🏡 我的主页\",\"link\":\"/\"},{\"text\":\"📝 我的文章\",\"items\":[{\"text\":\"📚 面试笔记\",\"link\":\"/pages/Articles/InterviewNotes/\"},{\"text\":\"📐 设计模式\",\"link\":\"/pages/Articles/DesignPattern/DesignPattern\"},{\"text\":\"📋 Git 提交规范\",\"link\":\"/pages/Articles/GitCommitConventions/GitCommitConventions\"}]},{\"text\":\"📖 我的文档\",\"items\":[{\"text\":\"🌱 Spring 小记\",\"link\":\"/pages/Documents/SpringNotes/\"},{\"text\":\"🗄️ MySQL 数据库\",\"link\":\"/pages/Documents/SQL/\"}]},{\"text\":\"🗞 杂货\",\"items\":[{\"text\":\"🐍 Python 基础教程\",\"link\":\"/pages/Groceries/MAGAOPythonNotesS1\"}]},{\"text\":\"🎵 音乐站\",\"link\":\"/pages/Music/\"}],\"sidebar\":[{\"text\":\"📝 我的文章\",\"items\":[{\"text\":\"面试笔记\",\"link\":\"/pages/Articles/InterviewNotes/\",\"collapsed\":false,\"items\":[{\"text\":\"Java 技术栈\",\"collapsed\":false,\"items\":[{\"text\":\"Java 基础\",\"link\":\"/pages/Articles/InterviewNotes/Java/JavaBasic/JavaBasic\"},{\"text\":\"Java 集合框架\",\"link\":\"/pages/Articles/InterviewNotes/Java/JavaCollection/JavaCollection\"},{\"text\":\"Java 并发编程\",\"link\":\"/pages/Articles/InterviewNotes/Java/JavaConcurrency/JavaConcurrency\"},{\"text\":\"JVM 虚拟机\",\"link\":\"/pages/Articles/InterviewNotes/Java/JVM/JVM\"}]},{\"text\":\"中间件技术\",\"collapsed\":false,\"items\":[{\"text\":\"Redis 笔记\",\"link\":\"/pages/Articles/InterviewNotes/Redis/RedisNotes\"}]}]},{\"text\":\"设计模式\",\"link\":\"/pages/Articles/DesignPattern/DesignPattern\",\"collapsed\":false,\"items\":[{\"text\":\"创建型设计模式\",\"collapsed\":false,\"items\":[{\"text\":\"工厂模式\",\"link\":\"/pages/Articles/DesignPattern/CreationalPattern/FactoryPattern/FactoryPattern\"},{\"text\":\"单例模式\",\"link\":\"/pages/Articles/DesignPattern/CreationalPattern/SingletonPattern/SingletonPattern\"},{\"text\":\"建造者模式\",\"link\":\"/pages/Articles/DesignPattern/CreationalPattern/BuilderPattern/BuilderPattern\"},{\"text\":\"原型模式\",\"link\":\"/pages/Articles/DesignPattern/CreationalPattern/PrototypePattern/PrototypePattern\"}]},{\"text\":\"结构型设计模式\",\"collapsed\":false,\"items\":[{\"text\":\"适配器模式\",\"link\":\"/pages/Articles/DesignPattern/StructuralPattern/AdapterPattern/AdapterPattern\"},{\"text\":\"桥接模式\",\"link\":\"/pages/Articles/DesignPattern/StructuralPattern/BridgePattern/BridgePattern\"},{\"text\":\"过滤器模式\",\"link\":\"/pages/Articles/DesignPattern/StructuralPattern/FilterPattern/FilterPattern\"},{\"text\":\"组合模式\",\"link\":\"/pages/Articles/DesignPattern/StructuralPattern/CompositePattern/CompositePattern\"},{\"text\":\"装饰器模式\",\"link\":\"/pages/Articles/DesignPattern/StructuralPattern/DecoratorPattern/DecoratorPattern\"},{\"text\":\"外观模式\",\"link\":\"/pages/Articles/DesignPattern/StructuralPattern/FacadePattern/FacadePattern\"},{\"text\":\"享元模式\",\"link\":\"/pages/Articles/DesignPattern/StructuralPattern/FlyweightPattern/FlyweightPattern\"},{\"text\":\"代理模式\",\"link\":\"/pages/Articles/DesignPattern/StructuralPattern/ProxyPattern/ProxyPattern\"}]},{\"text\":\"行为型设计模式\",\"collapsed\":false,\"items\":[{\"text\":\"责任链模式\",\"link\":\"/pages/Articles/DesignPattern/BehavioralPattern/ChainOfResponsibilityPattern/ChainOfResponsibilityPattern\"}]}]},{\"text\":\"Git 提交规范\",\"link\":\"/pages/Articles/GitCommitConventions/GitCommitConventions\"}]},{\"text\":\"📖 我的文档\",\"items\":[{\"text\":\"Spring 小记\",\"link\":\"/pages/Documents/SpringNotes/\",\"collapsed\":false,\"items\":[{\"text\":\"Spring MVC\",\"collapsed\":false,\"items\":[{\"text\":\"ResponseBodyEmitter 使用\",\"link\":\"/pages/Documents/SpringNotes/SpringMVC/ResponseBodyEmitter\"}]}]},{\"text\":\"MySQL 数据库\",\"link\":\"/pages/Documents/SQL/\",\"collapsed\":false,\"items\":[{\"text\":\"🎯 基础篇\",\"collapsed\":true,\"items\":[{\"text\":\"01：基础指令\",\"link\":\"/pages/Documents/SQL/01：基础指令\"},{\"text\":\"02：函数\",\"link\":\"/pages/Documents/SQL/02：函数\"},{\"text\":\"03：约束\",\"link\":\"/pages/Documents/SQL/03：约束\"},{\"text\":\"04：多表查询\",\"link\":\"/pages/Documents/SQL/04：多表查询\"}]},{\"text\":\"🚀 进阶篇\",\"collapsed\":true,\"items\":[{\"text\":\"05：事务\",\"link\":\"/pages/Documents/SQL/05：事务\"},{\"text\":\"06：存储引擎\",\"link\":\"/pages/Documents/SQL/06：存储引擎\"},{\"text\":\"07：索引\",\"link\":\"/pages/Documents/SQL/07：索引\"},{\"text\":\"08：性能分析\",\"link\":\"/pages/Documents/SQL/08：性能分析\"},{\"text\":\"09：SQL优化\",\"link\":\"/pages/Documents/SQL/09：SQL优化\"}]},{\"text\":\"💎 高级篇\",\"collapsed\":true,\"items\":[{\"text\":\"10：视图\",\"link\":\"/pages/Documents/SQL/10：视图\"},{\"text\":\"11：存储\",\"link\":\"/pages/Documents/SQL/11：存储\"},{\"text\":\"12：触发器\",\"link\":\"/pages/Documents/SQL/12：触发器\"},{\"text\":\"13：锁\",\"link\":\"/pages/Documents/SQL/13：锁\"},{\"text\":\"14：InnoDB\",\"link\":\"/pages/Documents/SQL/14：InnoDB\"}]},{\"text\":\"🔧 运维篇\",\"collapsed\":true,\"items\":[{\"text\":\"15：MySQL管理\",\"link\":\"/pages/Documents/SQL/15：MySQL管理\"},{\"text\":\"16：日志\",\"link\":\"/pages/Documents/SQL/16：日志\"},{\"text\":\"17：主从复制\",\"link\":\"/pages/Documents/SQL/17：主从复制\"},{\"text\":\"18：分库分表\",\"link\":\"/pages/Documents/SQL/18：分库分表\"}]}]}]},{\"text\":\"🗞 杂货\",\"items\":[{\"text\":\"Python 基础教程\",\"link\":\"/pages/Groceries/MAGAOPythonNotesS1\"}]}],\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/BanXiaNa\"}],\"returnToTopLabel\":\"返回顶部\",\"outlineTitle\":\"目录\",\"outline\":{\"level\":[1,6],\"label\":\"目录\"},\"lastUpdated\":{\"text\":\"最后更新于\",\"formatOptions\":{\"dateStyle\":\"full\",\"timeStyle\":\"short\"}},\"footer\":{\"message\":\"Contact me: 1943284256@qq.com\",\"copyright\":\"©2026 XIA All rights reserved.\"}},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false,\"additionalConfig\":{}}");</script>
    
  </body>
</html>