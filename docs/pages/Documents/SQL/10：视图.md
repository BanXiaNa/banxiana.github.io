# 视图

视图作为表存在于数据库，但是并不存储数据，而是存储查询逻辑，每次调用视图的时候，就执行一遍这个封装好的逻辑。

## 创建视图

```mysql
create [or replace] view view_name as select...;
```

**or replace**：如果这个视图存在就更新

---

## 查询创建语句

```MySQL
show create view view_name;
```

---

## 查询视图

 视图在数据库中是作为表出现的，因此查询操作和查询表的语句相同

---

## 修改视图

```mysql
# 方法一：
create or replace view view_name as select ...;
# 方法二
alter view view_name as select...;
```

---

## 删除视图

```mysql
drop view [if exists] view_name [,vire_name];
```

---

## 检查选项

视图是以表的形式呈现的，，那自然也可以进行增删改查，当然，视图存储的是逻辑，如果加入了数据，会加入到基表，而不是视图，如果添加了视图查询不到的条目，就会出现问题。
为了解决问题，就诞生了检查选项用来检查操作是否合法

### 添加检查选项

在创建视图语句之后加上 with [cascade  | local] check option 视图就会检查更新，阻止不符合视图创建规范的SQL执行。
另外，MySQL允许根据视图创建视图，因此，检查范围成了问题。为了确定检查的范围，mysql加入了两个范围限定
**cascade**：级联，如果在子视图加入了这个条件，通过子视图更新基表的操作会检查父视图的规范。
**local**：局部检查，如果父视图没有定义条件，就不检查

---

## 视图的更新

视图可以更新基表的条件：视图的数据必须是和基表是一对一对应的关系，如果数据经过了函数加工，就不能通过视图更新基表

例如：聚合函数，筛选函数，分组，等函数

---

## 视图作用

这个玩意有什么用呢？：

**简单**：简化操作，对于复杂度语句，使用频次比较高的语句都适合转化为视图去呈现。
**安全**：可以只对用户授予视图权限，使得用户只能看到视图所展示的数据，可以保护数据
**数据独立**：屏蔽基表的变化对视图的影响（可以取别名，只查看某些字段）

---

# 